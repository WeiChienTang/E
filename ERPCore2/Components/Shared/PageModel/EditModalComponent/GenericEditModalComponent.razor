@* 泛型Edit Modal組件 *@
@attribute [Authorize]
@inject IJSRuntime JSRuntime
@inject INotificationService NotificationService
@using System.Reflection
@using ERPCore2.Components.Shared.BaseModal.Modals
@using ERPCore2.Components.Shared.BaseModal.BaseFrameworkComponent
@typeparam TEntity where TEntity : BaseEntity, new()
@typeparam TService

@{
    // 權限檢查 - 如果沒有設定權限，預設拒絕存取
    string requiredPermission = RequiredPermission;
    if (string.IsNullOrWhiteSpace(requiredPermission))
    {
        // 安全起見，如果沒有設定權限，設定為一個不存在的權限以確保拒絕存取
        requiredPermission = "System.RequiredPermissionNotSet";
    }
}

<PagePermissionCheck RequiredPermission="@requiredPermission">

<BaseModalComponent IsVisible="@IsVisible"
                   IsVisibleChanged="@IsVisibleChanged"
                   Title="@GetModalTitle()"
                   Icon="@GetModalIcon()"
                   Size="@ConvertToBaseModalSize(Size)"
                   HeaderColor="BaseModalComponent.HeaderVariant.ProjectPrimary"
                   CloseOnEscape="true"
                   CloseOnBackdropClick="false"
                   ShowCloseButton="true"
                   IsLoading="@IsLoading"
                   LoadingMessage="@LoadingMessage"
                   ErrorMessage="@ErrorMessage"
                   ShowFooter="@(Entity != null && Entity.Id > 0)"
                   AuditInfo="@GetAuditInfo()"
                   BodyCssClass="p-0"
                   OnClose="@HandleCancel">
    
    <HeaderButtons>
        @* ===== Modal Actions 按鈕區塊 ===== *@
        <div class="w-100 d-flex align-items-center px-2">
            @* 最左側：自訂操作按鈕（例如：轉入庫、轉沖款等業務流程按鈕） *@
            @if (CustomActionButtons != null)
            {
                <div class="d-flex gap-2 me-auto">
                    @CustomActionButtons
                </div>
            }
            
            @* 左側/中間：狀態訊息顯示（整合審核和其他所有狀態訊息） *@
            <div class="@(CustomActionButtons == null ? "flex-grow-1" : "")">
                @if (ShouldShowStatusMessage() && !IsLoading && Entity != null && Entity.Id > 0 && !string.IsNullOrEmpty(_cachedStatusMessage))
                {
                    <span class="badge bg-@GetBadgeColorClass(_cachedStatusVariant) me-2 fs-6">
                        <i class="@_cachedStatusIcon me-1"></i>@_cachedStatusMessage
                    </span>
                }
            </div>
            
            @* 中央：審核操作按鈕 *@
            @if (ShowApprovalSection && !IsLoading && Entity != null && Entity.Id > 0)
            {
                @* 有權限者才能看到審核通過/駁回按鈕 *@
                @if (!IsEntityApproved())
                {
                    <PermissionCheck Permission="@ApprovalPermission">
                        <div class="d-flex gap-2 me-3">
                            <GenericButtonComponent Text="通過" 
                                                  Variant="ButtonVariant.Success" 
                                                  OnClick="HandleApprove" 
                                                  IsDisabled="@(IsSubmitting || IsApproving || IsRejecting)"
                                                  IsLoading="@IsApproving" />
                            <GenericButtonComponent Text="駁回" 
                                                  Variant="ButtonVariant.Danger" 
                                                  OnClick="OpenRejectConfirmModal" 
                                                  IsDisabled="@(IsSubmitting || IsApproving || IsRejecting)"
                                                  IsLoading="@IsRejecting" />
                        </div>
                    </PermissionCheck>
                }
            }
            
            @* 右側：原有的主要操作按鈕 *@
            <div class="d-flex gap-2">
                @if (ShowSaveButton)
                {
                    <GenericButtonComponent Text="@SaveButtonText" 
                                          Variant="ButtonVariant.Primary" 
                                          OnClick="HandleSave" 
                                          IsDisabled="@(IsSubmitting || IsLoading)" 
                                          IsLoading="@IsSubmitting" />
                }
                
                @* 返回編輯按鈕（只在新增模式且有最後一筆記錄時顯示） *@
                @if (ShowReturnToLastButton && !Id.HasValue && _lastRecordId.HasValue)
                {
                    <GenericButtonComponent Text="@ReturnToLastButtonText" 
                                          Variant="ButtonVariant.Success" 
                                          OnClick="HandleReturnToLast" 
                                          IsDisabled="@(IsSubmitting || IsLoading)"
                                          Title="返回到最後一筆儲存的資料" />
                }
                
                @* 記錄導航按鈕（在儲存按鈕右側，只在編輯模式顯示） *@
                @* 目前此功能存在很大的問題，詳情可以看 Readme_上下筆失敗測試，為將來如果要繼續測試可以嘗試修改*@
                @if (EnableNavigation && Entity != null && Entity.Id > 0)
                {
                    <GenericButtonComponent Text="上筆" 
                                          Variant="ButtonVariant.Success" 
                                          OnClick="HandlePrevious"
                                          IsDisabled="@(IsSubmitting || IsLoading)"
                                          Title="@GetPreviousButtonTitle()" />
                    
                    <GenericButtonComponent Text="下筆" 
                                          Variant="ButtonVariant.Success"
                                          OnClick="HandleNext"
                                          IsDisabled="@(IsSubmitting || IsLoading)"
                                          Title="@GetNextButtonTitle()" />
                }
                
                @if (ShowPrintButton)
                {
                    <GenericButtonComponent Text="@PrintButtonText" 
                                          Variant="ButtonVariant.Info" 
                                          OnClick="HandlePrint" 
                                          IsDisabled="@(IsSubmitting || IsLoading)" />
                }
                
                @if (ShowDeleteButton && Entity != null && Entity.Id > 0 && IsEntityDeletable(Entity))
                {
                    <GenericButtonComponent Text="刪除" 
                                          Variant="ButtonVariant.Danger" 
                                          OnClick="DeleteEntityAsync" 
                                          IsDisabled="@(IsSubmitting || IsLoading)" />
                }
            </div>
        </div>
    </HeaderButtons>
    
    <BodyContent>
        @* 表單頂部內容（在所有欄位之前） *@
        @if (FormHeaderContent != null)
        {
            <div class="form-header-content px-3 pt-3">
                <CascadingValue Value="@editContext">
                    @FormHeaderContent
                </CascadingValue>
            </div>
        }

        @* 基本表單 *@
        @if (UseGenericForm && FormFields.Any())
        {
            <div class="edit-form-container px-3">
                <GenericFormComponent @key="@(Entity?.Id ?? 0)"
                                    TModel="TEntity"
                                    Model="@Entity"
                                    FieldDefinitions="@GetProcessedFormFields()"
                                    FieldSections="@FormSections"
                                    OnFieldChanged="@HandleFieldChanged" />
            </div>
        }

        @* 自訂表單內容 *@
        @if (CustomFormContent != null)
        {
            <div class="custom-form-content px-3">
                <CascadingValue Value="@editContext">
                    @CustomFormContent
                </CascadingValue>
            </div>
        }

        @* 自訂模組系統 *@
        @if (CustomModules != null && CustomModules.Any())
        {
            @foreach (var module in CustomModules.Where(m => m.IsVisible).OrderBy(m => m.Order))
            {
                @if (module.Content != null)
                {
                    <div class="@GetModuleCssClass(module) custom-module px-3">
                        @if (!string.IsNullOrWhiteSpace(module.Title))
                        {
                            <h6 class="mb-3">@module.Title</h6>
                        }
                        <CascadingValue Value="@editContext">
                            @module.Content
                        </CascadingValue>
                    </div>
                }
            }
        }

        @* 額外區段 *@
        @if (AdditionalSections != null)
        {
            <div class="additional-sections px-3 pb-3">
                <CascadingValue Value="@editContext">
                    @AdditionalSections
                </CascadingValue>
            </div>
        }
    </BodyContent>
    
</BaseModalComponent>

@* 駁回確認 Modal *@
<RejectConfirmModalComponent @ref="_rejectConfirmModal"
                            IsVisible="@_isRejectConfirmModalVisible"
                            IsVisibleChanged="@((bool value) => _isRejectConfirmModalVisible = value)"
                            Title="確認駁回"
                            OnConfirm="@HandleRejectConfirm"
                            OnCancel="@HandleRejectCancel" />

</PagePermissionCheck>

@code {
    // ===== 自訂模組類別 =====
    
    /// <summary>
    /// 自訂模組類別，用於定義可重複使用的頁面模組
    /// </summary>
    public class CustomModule
    {
        /// <summary>
        /// 模組標題（可選）
        /// </summary>
        public string? Title { get; set; }
        
        /// <summary>
        /// 模組內容
        /// </summary>
        public RenderFragment? Content { get; set; }
        
        /// <summary>
        /// 排序順序，數字越小越靠前
        /// </summary>
        public int Order { get; set; } = 0;
        
        /// <summary>
        /// 自訂 CSS 類別
        /// </summary>
        public string? CssClass { get; set; }
        
        /// <summary>
        /// 模組唯一識別符（可選，用於除錯或特殊處理）
        /// </summary>
        public string? Id { get; set; }
        
        /// <summary>
        /// 是否顯示此模組
        /// </summary>
        public bool IsVisible { get; set; } = true;
    }
    
    // ===== 參數 =====
    
    // 顯示控制
    [Parameter] public bool IsVisible { get; set; } = false;
    [Parameter] public EventCallback<bool> IsVisibleChanged { get; set; }
    
    // 權限檢查參數
    [Parameter] public string RequiredPermission { get; set; } = "";
    
    // 核心參數
    [Parameter] public int? Id { get; set; }
    [Parameter] public EventCallback<int?> IdChanged { get; set; }
    [Parameter] public TEntity Entity { get; set; } = new();
    [Parameter] public TService Service { get; set; } = default!;
    
    // 頁面基本設定
    [Parameter] public string EntityName { get; set; } = "資料";
    [Parameter] public string EntityNamePlural { get; set; } = "資料";
    [Parameter] public string ModalTitle { get; set; } = string.Empty;
    [Parameter] public ModalSize Size { get; set; } = ModalSize.Desktop;
    
    // 按鈕設定
    [Parameter] public string SaveButtonText { get; set; } = "儲存";
    [Parameter] public string CancelButtonText { get; set; } = "取消";
    [Parameter] public string PrintButtonText { get; set; } = "列印";
    [Parameter] public bool ShowSaveButton { get; set; } = true;
    [Parameter] public bool ShowPrintButton { get; set; } = false;
    [Parameter] public bool ShowDeleteButton { get; set; } = true;
    [Parameter] public bool ShowReturnToLastButton { get; set; } = true;
    [Parameter] public string ReturnToLastButtonText { get; set; } = "返回編輯";
    
    /// <summary>
    /// 是否啟用記錄導航功能（上一筆/下一筆按鈕）
    /// </summary>
    [Parameter] public bool EnableNavigation { get; set; } = true;
    
    /// <summary>
    /// 是否在儲存成功後自動關閉 Modal（預設為 false，不關閉）
    /// </summary>
    [Parameter] public bool CloseOnSave { get; set; } = false;
    
    // 自訂操作按鈕區域（顯示在頂部按鈕列的最左側）
    [Parameter] public RenderFragment? CustomActionButtons { get; set; }
    
    // 自訂按鈕區域（顯示在 Modal Header 中）
    [Parameter] public RenderFragment? CustomButtons { get; set; }
    
    // 表單設定
    [Parameter] public bool UseGenericForm { get; set; } = true;
    [Parameter] public List<FormFieldDefinition> FormFields { get; set; } = new();
    [Parameter] public Dictionary<string, string> FormSections { get; set; } = new();
    
    // AutoComplete 智能預填支援
    [Parameter] public Dictionary<string, Func<string, Dictionary<string, object?>>>? AutoCompletePrefillers { get; set; }
    [Parameter] public Dictionary<string, object>? ModalManagers { get; set; }
    
    // AutoComplete 自動搜尋集合支援
    [Parameter] public Dictionary<string, IEnumerable<object>>? AutoCompleteCollections { get; set; }
    [Parameter] public Dictionary<string, string>? AutoCompleteDisplayProperties { get; set; }
    [Parameter] public Dictionary<string, string>? AutoCompleteValueProperties { get; set; }
    [Parameter] public Dictionary<string, int>? AutoCompleteMaxResults { get; set; }
    
    // 自訂內容
    [Parameter] public RenderFragment? FormHeaderContent { get; set; }  // 表單頂部內容（在欄位之前）
    [Parameter] public RenderFragment? CustomFormContent { get; set; }
    [Parameter] public RenderFragment? AdditionalSections { get; set; }
    
    // 自訂模組系統
    [Parameter] public List<CustomModule> CustomModules { get; set; } = new();
    
    // 委派參數 - 資料操作
    [Parameter] public Func<Task<TEntity?>>? DataLoader { get; set; }
    [Parameter] public Func<TEntity, Task<bool>>? SaveHandler { get; set; }
    [Parameter] public Func<Task>? AdditionalDataLoader { get; set; }
    
    // 通用Save相關參數
    [Parameter] public Func<TEntity, Task<bool>>? CustomValidator { get; set; }
    [Parameter] public Func<TEntity, Task>? BeforeSave { get; set; }
    [Parameter] public Func<TEntity, Task>? AfterSave { get; set; }
    [Parameter] public bool UseGenericSave { get; set; } = false;
    [Parameter] public string SaveSuccessMessage { get; set; } = "儲存成功";
    [Parameter] public string SaveFailureMessage { get; set; } = "儲存失敗";
    
    // 委派參數 - 事件處理
    [Parameter] public EventCallback OnSaveSuccess { get; set; }
    [Parameter] public EventCallback OnSaveFailure { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public EventCallback OnPrint { get; set; }
    [Parameter] public Func<(string PropertyName, object? Value), Task>? OnFieldChanged { get; set; }
    
    /// <summary>
    /// 實體載入完成事件（導航切換時觸發）
    /// 參數為已載入的實體 ID，用於通知父組件重新載入相關資料（如明細）
    /// </summary>
    [Parameter] public EventCallback<int> OnEntityLoaded { get; set; }
    
    // === 通用刪除功能相關參數 ===
    [Parameter] public Func<TEntity, string> GetEntityDisplayName { get; set; } = entity => entity.Id.ToString();
    [Parameter] public string DeleteSuccessMessage { get; set; } = "";
    [Parameter] public string DeleteConfirmMessage { get; set; } = "";
    [Parameter] public Func<TEntity, bool>? CanDelete { get; set; }
    [Parameter] public bool EnableSystemDataProtection { get; set; } = true;
    [Parameter] public Func<TEntity, Task<bool>>? CustomDeleteHandler { get; set; }
    
    // 訊息設定
    [Parameter] public string LoadingMessage { get; set; } = "載入資料中...";
    
    // ===== 通用狀態訊息參數 =====
    
    /// <summary>
    /// 顯示狀態訊息（可用於審核狀態、警告、提示等任何情境）
    /// </summary>
    [Parameter] public string? StatusMessage { get; set; }
    
    /// <summary>
    /// 狀態訊息的徽章顏色變體
    /// </summary>
    [Parameter] public BadgeVariant StatusBadgeVariant { get; set; } = BadgeVariant.Info;
    
    /// <summary>
    /// 狀態訊息的圖示類別
    /// </summary>
    [Parameter] public string StatusIconClass { get; set; } = "fas fa-info-circle";
    
    /// <summary>
    /// 是否顯示狀態訊息（預設為 false）
    /// </summary>
    [Parameter] public bool ShowStatusMessage { get; set; } = false;
    
    /// <summary>
    /// 動態取得狀態訊息的函式（優先於 StatusMessage）
    /// 用於審核狀態等需要動態計算的情境
    /// </summary>
    [Parameter] public Func<Task<(string Message, BadgeVariant Variant, string IconClass)?>>? GetStatusMessage { get; set; }
    
    // ===== 審核功能參數（向下相容，整合到狀態訊息系統） =====
    
    [Parameter] public bool ShowApprovalSection { get; set; } = false;
    [Parameter] public string ApprovalPermission { get; set; } = string.Empty;
    [Parameter] public Func<Task<bool>>? OnApprove { get; set; }
    [Parameter] public Func<Task<bool>>? OnReject { get; set; }
    
    // 駁回確認 Modal 相關參數
    [Parameter] public Func<string, Task<bool>>? OnRejectWithReason { get; set; }
    // 移除 GetApprovalStatus，改用 GetStatusMessage
    
    // ===== 內部狀態 =====
    
    private bool IsLoading { get; set; } = false;
    private bool IsSubmitting { get; set; } = false;
    private string ErrorMessage { get; set; } = string.Empty;
    private int? _lastId = null;
    private bool _lastVisible = false;
    private readonly SemaphoreSlim _loadingSemaphore = new(1, 1);
    private bool _isNavigating = false;  // 標記是否正在執行導航操作
    private EditContext? editContext;
    
    // 審核狀態
    private bool IsApproving { get; set; } = false;
    private bool IsRejecting { get; set; } = false;
    
    // 駁回確認 Modal
    private RejectConfirmModalComponent? _rejectConfirmModal;
    private bool _isRejectConfirmModalVisible = false;
    
    // 狀態訊息快取
    private string? _cachedStatusMessage;
    private BadgeVariant _cachedStatusVariant = BadgeVariant.Info;
    private string _cachedStatusIcon = "fas fa-info-circle";
    
    // AutoComplete 搜尋關鍵字追蹤
    private readonly Dictionary<string, string> _lastSearchTerms = new();
    
    // AutoComplete 版本號機制 - 用於強制刷新 AutoComplete 欄位顯示
    private int _autoCompleteVersion = 0;
    
    // 記錄導航狀態
    private int? _currentId = null;  // 內部追蹤的當前 ID（支援導航時的 ID 變更）
    private int? _previousId = null;
    private int? _nextId = null;
    private int? _firstId = null;  // 第一筆記錄的 ID
    private int? _lastRecordId = null;   // 最後一筆記錄的 ID
    
    // ===== Modal 尺寸列舉 =====
    
    public enum ModalSize
    {
        Small,
        Default,
        Large,
        ExtraLarge,
        Desktop  // 新增桌面尺寸，更大更適合電腦螢幕
    }
    
    // ===== 狀態徽章顏色列舉 =====
    
    /// <summary>
    /// Bootstrap 徽章顏色變體
    /// </summary>
    public enum BadgeVariant
    {
        Primary,    // 藍色 - 主要
        Secondary,  // 灰色 - 次要
        Success,    // 綠色 - 成功
        Danger,     // 紅色 - 危險/錯誤
        Warning,    // 黃色 - 警告
        Info,       // 淺藍色 - 資訊（預設）
        Light,      // 淺色
        Dark        // 深色
    }
    
    // ===== 生命週期方法 =====
    
    protected override Task OnInitializedAsync()
    {
        // 初始化 EditContext
        editContext = new EditContext(Entity);
        return Task.CompletedTask;
    }
    
    protected override async Task OnParametersSetAsync()
    {
        // 同步 _currentId 與 Id（除非正在導航中）
        if (!_isNavigating)
        {
            _currentId = Id;
        }
        
        // 只有當 Modal 顯示且 Id 參數真的變化時才重新載入
        if (IsVisible && !_lastVisible)
        {
            // Modal 剛打開
            _lastVisible = true;
            _lastId = Id;
            await LoadAllData();
        }
        else if (IsVisible && _lastId != Id)
        {
            // Modal 已打開但 Id 變更
            _lastId = Id;
            await LoadAllData();
        }
        else if (!IsVisible && _lastVisible)
        {
            // Modal 剛關閉
            _lastVisible = false;
            ResetState();
        }
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsVisible && firstRender)
        {
            await SetupTabNavigationAsync();
        }
    }
    
    // ===== Tab 導航處理 =====
    
    /// <summary>
    /// 設置 Tab 鍵導航，當焦點在按鈕上時自動跳到下一個非按鈕元素
    /// </summary>
    private async Task SetupTabNavigationAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("setupButtonTabNavigation");
        }
        catch (Exception ex)
        {
            LogError("SetupTabNavigation", ex);
        }
    }
    
    /// <summary>
    /// 清理 Tab 鍵導航事件監聽器
    /// </summary>
    private async Task CleanupTabNavigationAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("cleanupButtonTabNavigation");
        }
        catch (Exception ex)
        {
            LogError("CleanupTabNavigation", ex);
        }
    }
    
    // ===== ESC 鍵處理 =====
    
    // ESC 鍵監聽、處理和清理方法已移除，由 BaseModalComponent 自動處理

    
    // ===== 資料載入方法 =====
    
    private async Task LoadAllData()
    {
        await _loadingSemaphore.WaitAsync();
        try
        {
            IsLoading = true;
            ErrorMessage = string.Empty;
            StateHasChanged();
            
            // 載入額外資料（如選項列表）
            if (AdditionalDataLoader != null)
            {
                await AdditionalDataLoader();
            }
            
            // 載入實體資料
            //  關鍵修復：如果正在導航，跳過 DataLoader（Entity 已由 NavigateToRecordAsync 直接載入）
            if (!_isNavigating && DataLoader != null)
            {
                var loadedEntity = await DataLoader();
                if (loadedEntity != null)
                {
                    Entity = loadedEntity;
                    // 重新建立 EditContext
                    editContext = new EditContext(Entity);
                    
                    // 方案三：主動更新所有 ActionButtons，確保按鈕狀態與實體資料同步
                    UpdateAllActionButtons();
                }
            }
            else if (_isNavigating)
            {
                // 導航模式：Entity 已由 NavigateToRecordAsync 載入，只需更新 ActionButtons
                UpdateAllActionButtons();
            }
            
            // 載入狀態訊息資料
            await LoadStatusMessageData();
            
            // 載入導航狀態
            // 新增模式：只載入 _lastRecordId（用於返回編輯按鈕）
            // 編輯模式：載入完整導航資訊（上一筆、下一筆等）
            await LoadNavigationStateAsync();
        }
        catch (Exception ex)
        {
            ErrorMessage = $"載入資料時發生錯誤：{ex.Message}";
            LogError("LoadAllData", ex);
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
            _loadingSemaphore.Release();
        }
    }
    
    /// <summary>
    /// 載入狀態訊息資料（整合審核和其他所有狀態訊息）
    /// </summary>
    private async Task LoadStatusMessageData()
    {
        try
        {
            if (!ShouldShowStatusMessage() || Entity == null || Entity.Id <= 0)
                return;

            // 優先使用動態取得函式
            if (GetStatusMessage != null)
            {
                var result = await GetStatusMessage();
                if (result.HasValue)
                {
                    _cachedStatusMessage = result.Value.Message;
                    _cachedStatusVariant = result.Value.Variant;
                    _cachedStatusIcon = result.Value.IconClass;
                }
            }
            // 其次使用靜態設定值
            else if (!string.IsNullOrEmpty(StatusMessage))
            {
                _cachedStatusMessage = StatusMessage;
                _cachedStatusVariant = StatusBadgeVariant;
                _cachedStatusIcon = StatusIconClass;
            }
        }
        catch (Exception ex)
        {
            LogError("LoadStatusMessageData", ex);
            // 不拋出例外，避免影響主要資料載入
        }
    }
    
    /// <summary>
    /// 重新載入實體資料（公共方法，解決組件參數不應在外部設置的問題）
    /// </summary>
    public async Task RefreshEntityAsync()
    {
        if (DataLoader != null && Entity != null && Entity.Id > 0)
        {
            var reloadedEntity = await DataLoader();
            if (reloadedEntity != null)
            {
                Entity = reloadedEntity;
                editContext = new EditContext(Entity);
                await LoadStatusMessageData(); // 重新載入狀態訊息
                StateHasChanged();
            }
        }
    }
    
    /// <summary>
    /// 重新載入額外資料並刷新 AutoComplete 欄位顯示
    /// 當子 Modal 編輯並儲存後，呼叫此方法以更新 AutoComplete 選項和顯示內容
    /// </summary>
    public async Task RefreshAutoCompleteFieldsAsync()
    {
        try
        {
            // 1. 重新載入額外資料（更新 AutoCompleteCollections）
            if (AdditionalDataLoader != null)
            {
                await AdditionalDataLoader();
            }
            
            // 2. 遞增版本號，強制 Blazor 重新建立 GenericFormComponent
            _autoCompleteVersion++;
            
            // 3. 更新所有 ActionButtons 狀態
            UpdateAllActionButtons();
            
            // 4. 通知 UI 更新
            StateHasChanged();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            LogError("RefreshAutoCompleteFields", ex);
        }
    }
    
    // ===== 事件處理方法 =====
    
    private async Task HandleSave()
    {
        if (IsSubmitting) return;
        
        try
        {
            IsSubmitting = true;
            StateHasChanged();
            
            bool success;
            
            if (UseGenericSave)
            {
                success = await GenericSave(Entity);
            }
            else if (SaveHandler != null)
            {
                success = await SaveHandler(Entity);
            }
            else
            {
                await ShowErrorMessage("未設定儲存處理程序");
                return;
            }
            
            if (success)
            {
                await ShowSuccessMessage(SaveSuccessMessage);
                
                //  關鍵修復：檢測從新增模式轉為編輯模式
                // 當儲存成功且是從新增（Id 為 null）變為編輯（Entity.Id > 0）時
                // 自動更新 Id 參數並重新載入所有資料，確保 Modal 狀態正確
                bool wasNewRecord = !Id.HasValue;
                if (wasNewRecord && Entity != null && Entity.Id > 0)
                {
                    //  關鍵：先更新 _lastId，避免觸發 OnParametersSetAsync 的重複載入
                    _lastId = Entity.Id;
                    Id = Entity.Id;
                    
                    //  修復：觸發 IdChanged 事件，更新父組件的綁定參數（如 PurchaseOrderId）
                    // 這確保父組件可以正確判斷模式（新增/編輯）
                    if (IdChanged.HasDelegate)
                    {
                        await IdChanged.InvokeAsync(Entity.Id);
                    }
                    
                    // 重新載入所有資料（包含明細、狀態訊息、導航狀態等）
                    // 這確保了：
                    // 1. Modal 標題從「新增」變為「編輯」
                    // 2. 明細資料正確載入並顯示鎖定狀態
                    // 3. 審核按鈕、刪除按鈕等正確顯示
                    // 4. 相關單據的操作按鈕可以正常使用
                    await LoadAllData();
                }
                
                if (OnSaveSuccess.HasDelegate)
                {
                    await OnSaveSuccess.InvokeAsync();
                }
                
                // 根據 CloseOnSave 參數決定是否關閉 Modal
                if (CloseOnSave)
                {
                    await CloseModal();
                }
            }
            else
            {
                if (OnSaveFailure.HasDelegate)
                {
                    await OnSaveFailure.InvokeAsync();
                }
            }
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"儲存時發生錯誤：{ex.Message}");
            LogError("HandleSave", ex);
            
            if (OnSaveFailure.HasDelegate)
            {
                await OnSaveFailure.InvokeAsync();
            }
        }
        finally
        {
            IsSubmitting = false;
            StateHasChanged();
        }
    }
    
    private async Task HandleCancel()
    {
        try
        {
            if (OnCancel.HasDelegate)
            {
                await OnCancel.InvokeAsync();
            }
            
            await CloseModal();
        }
        catch (Exception ex)
        {
            LogError("HandleCancel", ex);
        }
    }
    
    private async Task HandlePrint()
    {
        if (OnPrint.HasDelegate)
        {
            await OnPrint.InvokeAsync();
        }
    }
    
    private async Task HandleApprove()
    {
        if (OnApprove == null || IsApproving || IsRejecting) return;
        
        try
        {
            IsApproving = true;
            StateHasChanged();
            
            var success = await OnApprove();
            
            if (success)
            {
                await ShowSuccessMessage("審核通過");
                
                // 重新載入實體資料以確保狀態同步
                await RefreshEntityAsync();
            }
            else
            {
                await ShowErrorMessage("審核通過失敗");
            }
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"審核通過時發生錯誤：{ex.Message}");
            LogError("HandleApprove", ex);
        }
        finally
        {
            IsApproving = false;
            StateHasChanged();
        }
    }
    
    /// <summary>
    /// 開啟駁回確認 Modal
    /// </summary>
    private void OpenRejectConfirmModal()
    {
        if (IsApproving || IsRejecting) return;
        
        _isRejectConfirmModalVisible = true;
        StateHasChanged();
    }
    
    /// <summary>
    /// 處理駁回確認 Modal 的確認事件
    /// </summary>
    private async Task HandleRejectConfirm(string rejectReason)
    {
        try
        {
            IsRejecting = true;
            StateHasChanged();
            
            bool success;
            
            // 優先使用帶駁回原因的委派
            if (OnRejectWithReason != null)
            {
                success = await OnRejectWithReason(rejectReason);
            }
            // 向下相容：使用原有的 OnReject 委派
            else if (OnReject != null)
            {
                success = await OnReject();
            }
            else
            {
                await ShowErrorMessage("未設定駁回處理程序");
                return;
            }
            
            if (success)
            {
                // 成功訊息由具體的處理方法（如 HandlePurchaseOrderRejectWithReason）顯示
                // 這裡只重新載入實體資料以確保狀態同步
                await RefreshEntityAsync();
            }
            else
            {
                // 失敗訊息也由具體的處理方法顯示，這裡不重複顯示
                // await ShowErrorMessage("審核駁回失敗");
            }
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"審核駁回時發生錯誤：{ex.Message}");
            LogError("HandleRejectConfirm", ex);
        }
        finally
        {
            IsRejecting = false;
            StateHasChanged();
        }
    }
    
    /// <summary>
    /// 處理駁回確認 Modal 的取消事件
    /// </summary>
    private Task HandleRejectCancel()
    {
        _isRejectConfirmModalVisible = false;
        StateHasChanged();
        return Task.CompletedTask;
    }
    
    /// <summary>
    /// 處理駁回（舊方法，保留以向下相容，但現在會開啟確認 Modal）
    /// </summary>
    private async Task HandleReject()
    {
        // 新版本：開啟駁回確認 Modal
        OpenRejectConfirmModal();
        await Task.CompletedTask;
    }
    

    
    private async Task CloseModal()
    {
        await CleanupTabNavigationAsync();
        await SetVisible(false);
    }
    
    private async Task SetVisible(bool visible)
    {
        if (IsVisible != visible)
        {
            await IsVisibleChanged.InvokeAsync(visible);
        }
    }
    
    // ===== 輔助方法 =====
    
    /// <summary>
    /// 檢查實體是否已審核通過
    /// </summary>
    private bool IsEntityApproved()
    {
        if (Entity == null) return false;
        
        // 檢查實體是否有 IsApproved 屬性
        var propertyInfo = typeof(TEntity).GetProperty("IsApproved");
        if (propertyInfo != null && propertyInfo.PropertyType == typeof(bool))
        {
            var isApproved = (bool?)propertyInfo.GetValue(Entity);
            return isApproved == true;
        }
        
        return false;
    }
    
    /// <summary>
    /// 處理已審核實體的完成按鈕點擊事件
    /// </summary>
    private async Task HandleApprovedEntityComplete()
    {
        try
        {
            // 觸發 OnSaveSuccess 事件以通知父組件刷新資料
            if (OnSaveSuccess.HasDelegate)
            {
                await OnSaveSuccess.InvokeAsync();
            }
            
            // 關閉 Modal
            await CloseModal();
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"完成操作時發生錯誤：{ex.Message}");
            LogError("HandleApprovedEntityComplete", ex);
        }
    }
    
    private string GetModalTitle()
    {
        if (!string.IsNullOrEmpty(ModalTitle))
            return ModalTitle;
            
        return Id.HasValue ? $"編輯{EntityName}" : $"新增{EntityName}";
    }
    
    private string GetModalIcon()
    {
        return Id.HasValue ? "fas fa-edit" : "fas fa-plus";
    }
    
    /// <summary>
    /// 轉換 ModalSize 到 BaseModalComponent.ModalSize
    /// </summary>
    private BaseModalComponent.ModalSize ConvertToBaseModalSize(ModalSize size)
    {
        return size switch
        {
            ModalSize.Small => BaseModalComponent.ModalSize.Small,
            ModalSize.Default => BaseModalComponent.ModalSize.Default,
            ModalSize.Large => BaseModalComponent.ModalSize.Large,
            ModalSize.ExtraLarge => BaseModalComponent.ModalSize.ExtraLarge,
            ModalSize.Desktop => BaseModalComponent.ModalSize.Desktop,
            _ => BaseModalComponent.ModalSize.Desktop
        };
    }
    
    /// <summary>
    /// 取得審計資訊
    /// </summary>
    private BaseModalComponent.ModalAuditInfo? GetAuditInfo()
    {
        if (Entity == null || Entity.Id <= 0)
            return null;
            
        return new BaseModalComponent.ModalAuditInfo
        {
            CreatedAt = Entity.CreatedAt,
            CreatedBy = Entity.CreatedBy ?? "系統",
            UpdatedAt = Entity.UpdatedAt,
            UpdatedBy = Entity.UpdatedBy ?? "系統"
        };
    }
    
    /// <summary>
    /// 取得自訂模組的 CSS 類別
    /// </summary>
    private string GetModuleCssClass(CustomModule module)
    {
        var cssClasses = new List<string>();
        
        // 基本間距類別（Modal 中使用較小的間距）
        if (!string.IsNullOrWhiteSpace(module.Title))
        {
            cssClasses.Add("mb-3");
        }
        else
        {
            cssClasses.Add("mb-2");
        }
        
        // 自訂 CSS 類別
        if (!string.IsNullOrWhiteSpace(module.CssClass))
        {
            cssClasses.Add(module.CssClass);
        }
        
        return string.Join(" ", cssClasses);
    }
    
    private void ResetState()
    {
        IsLoading = false;
        IsSubmitting = false;
        ErrorMessage = string.Empty;
        Entity = new();
        editContext = new EditContext(Entity);
        
        // 重置審核狀態
        IsApproving = false;
        IsRejecting = false;
        
        // 重置狀態訊息快取
        ResetStatusMessage();
    }
    
    // ===== 狀態訊息輔助方法 =====
    
    /// <summary>
    /// 判斷是否應該顯示狀態訊息
    /// </summary>
    private bool ShouldShowStatusMessage()
    {
        // 明確啟用顯示，或者啟用了審核區域（向下相容）
        return ShowStatusMessage || ShowApprovalSection;
    }
    
    /// <summary>
    /// 取得徽章顏色 CSS 類別
    /// </summary>
    private string GetBadgeColorClass(BadgeVariant variant)
    {
        return variant switch
        {
            BadgeVariant.Primary => "primary",
            BadgeVariant.Secondary => "secondary",
            BadgeVariant.Success => "success",
            BadgeVariant.Danger => "danger",
            BadgeVariant.Warning => "warning",
            BadgeVariant.Info => "info",
            BadgeVariant.Light => "light",
            BadgeVariant.Dark => "dark",
            _ => "info"
        };
    }
    
    /// <summary>
    /// 重置狀態訊息快取
    /// </summary>
    private void ResetStatusMessage()
    {
        _cachedStatusMessage = null;
        _cachedStatusVariant = BadgeVariant.Info;
        _cachedStatusIcon = "fas fa-info-circle";
    }
    
    // ===== 通知方法 =====
    
    private async Task ShowSuccessMessage(string message)
    {
        await NotificationService.ShowSuccessAsync(message);
    }
    
    private async Task ShowErrorMessage(string message)
    {
        await NotificationService.ShowErrorAsync(message);
    }
    
    private void LogError(string method, Exception ex)
    {
        // 使用系統日誌而非 console 輸出
        System.Diagnostics.Debug.WriteLine($"[GenericEditModalComponent.{method}] 錯誤：{ex.Message}");
    }
    
    // ===== 通用刪除操作 =====
    
    /// <summary>
    /// 通用刪除方法（永久刪除）
    /// </summary>
    public async Task DeleteEntityAsync()
    {
        if (Entity == null || Entity.Id <= 0)
            return;
            
        var displayName = GetEntityDisplayName(Entity);
        
        try
        {
            // 步驟0：檢查是否允許刪除此實體（雙重保護）
            if (!IsEntityDeletable(Entity))
            {
                await NotificationService.ShowWarningAsync($"此{EntityName}「{displayName}」無法刪除");
                return;
            }
            
            // 步驟1：先檢查是否可以刪除（檢查關聯）
            bool canDelete = false;
            string? canDeleteErrorMessage = null;
            
            if (CustomDeleteHandler != null)
            {
                // 如果有自訂刪除處理器，直接使用
                canDelete = true;
            }
            else
            {
                // 使用反射調用服務的 CanDeleteAsync 方法
                var canDeleteMethod = Service?.GetType().GetMethod("CanDeleteAsync", new[] { typeof(TEntity) });
                if (canDeleteMethod != null)
                {
                    var task = (Task)canDeleteMethod.Invoke(Service, new object[] { Entity })!;
                    await task;
                    
                    // 獲取結果
                    var resultProperty = task.GetType().GetProperty("Result");
                    if (resultProperty != null)
                    {
                        var result = resultProperty.GetValue(task);
                        var isSuccessProperty = result?.GetType().GetProperty("IsSuccess");
                        var errorMessageProperty = result?.GetType().GetProperty("ErrorMessage");
                        
                        if (isSuccessProperty != null)
                        {
                            canDelete = (bool)isSuccessProperty.GetValue(result)!;
                            if (!canDelete)
                            {
                                canDeleteErrorMessage = errorMessageProperty?.GetValue(result)?.ToString() ?? "無法刪除此資料";
                            }
                        }
                    }
                }
                else
                {
                    // 如果沒有 CanDeleteAsync 方法，預設允許刪除
                    canDelete = true;
                }
            }
            
            // 步驟2：如果不能刪除，顯示錯誤訊息
            if (!canDelete)
            {
                await NotificationService.ShowWarningAsync(canDeleteErrorMessage ?? $"無法刪除{EntityName}「{displayName}」，因為有其他資料正在使用此{EntityName}");
                return;
            }
            
            // 步驟3：確認刪除
            var confirmMessage = GetDeleteConfirmMessage(displayName);
            var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", confirmMessage);
            
            if (!confirmed)
                return;
                
            // 步驟4：執行刪除
            bool deleteSuccess = false;
            
            if (CustomDeleteHandler != null)
            {
                deleteSuccess = await CustomDeleteHandler(Entity);
            }
            else
            {
                // 使用預設的反射調用服務的 PermanentDeleteAsync 方法
                var deleteMethod = Service?.GetType().GetMethod("PermanentDeleteAsync", new[] { typeof(int) });
                if (deleteMethod != null)
                {
                    var task = (Task)deleteMethod.Invoke(Service, new object[] { Entity.Id })!;
                    await task;
                    
                    // 獲取結果
                    var resultProperty = task.GetType().GetProperty("Result");
                    if (resultProperty != null)
                    {                        
                        var result = resultProperty.GetValue(task);
                        var isSuccessProperty = result?.GetType().GetProperty("IsSuccess");
                        var errorMessageProperty = result?.GetType().GetProperty("ErrorMessage");
                        
                        if (isSuccessProperty != null)
                        {
                            var isSuccess = (bool)isSuccessProperty.GetValue(result)!;                            
                            if (isSuccess)
                            {
                                deleteSuccess = true;
                            }
                            else
                            {
                                var errorMessage = errorMessageProperty?.GetValue(result)?.ToString() ?? "刪除失敗";
                                await NotificationService.ShowErrorAsync($"刪除失敗：{errorMessage}");
                                return;
                            }
                        }
                    }                
                }               
                else
                {
                    await NotificationService.ShowErrorAsync("找不到永久刪除方法");
                    return;
                }
            }
            
            // 步驟5：顯示成功訊息並關閉 Modal
            if (deleteSuccess)
            {
                var successMessage = GetDeleteSuccessMessage();
                await NotificationService.ShowSuccessAsync(successMessage);
                
                // 觸發成功事件（通知父組件刷新資料）
                if (OnSaveSuccess.HasDelegate)
                {
                    await OnSaveSuccess.InvokeAsync();
                }
                
                // 關閉 Modal
                await CloseModal();
            }
        }            
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"刪除時發生錯誤：{ex.Message}");
            LogError("DeleteEntityAsync", ex);
        }
    }
    
    /// <summary>
    /// 判斷實體是否可以刪除
    /// 結合預設系統資料保護和自訂判斷邏輯
    /// </summary>
    private bool IsEntityDeletable(TEntity entity)
    {
        // 優先檢查自訂的 CanDelete 函數
        if (CanDelete != null)
        {
            return CanDelete(entity);
        }
        
        // 如果啟用系統資料保護，則檢查 CreatedBy
        if (EnableSystemDataProtection)
        {
            return entity.CreatedBy != "System";
        }
        
        // 預設允許刪除
        return true;
    }
    
    /// <summary>
    /// 取得刪除成功訊息，優先使用自訂值，否則根據 EntityName 自動產生
    /// </summary>
    private string GetDeleteSuccessMessage()
    {
        return !string.IsNullOrWhiteSpace(DeleteSuccessMessage) ? DeleteSuccessMessage : $"{EntityName}刪除成功";
    }
    
    /// <summary>
    /// 取得刪除確認訊息，優先使用自訂值，否則根據 EntityName 自動產生
    /// </summary>
    private string GetDeleteConfirmMessage(string displayName)
    {
        if (!string.IsNullOrWhiteSpace(DeleteConfirmMessage))
        {
            return string.Format(DeleteConfirmMessage, displayName);
        }
        return $"確定要刪除{EntityName}「{displayName}」嗎？";
    }
    
    // ===== 通用Save方法 =====
    
    /// <summary>
    /// 通用的保存方法，適用於大部分簡單實體
    /// </summary>
    private async Task<bool> GenericSave(TEntity entity)
    {
        try
        {
            // 自訂驗證
            if (CustomValidator != null && !await CustomValidator(entity))
            {
                return false;
            }
            
            // 儲存前處理
            if (BeforeSave != null)
            {
                await BeforeSave(entity);
            }
            
            // 直接轉型為基礎接口調用方法，避免反射問題
            var genericService = Service as IGenericManagementService<TEntity>;
            if (genericService == null)
            {
                await ShowErrorMessage("服務未實作泛型管理介面");
                return false;
            }
            
            ServiceResult<TEntity> serviceResult;
            
            if (Id.HasValue)
            {
                serviceResult = await genericService.UpdateAsync(entity);
            }
            else
            {
                serviceResult = await genericService.CreateAsync(entity);
            }
            
            var result = new ServiceResult
            {
                IsSuccess = serviceResult.IsSuccess,
                ErrorMessage = serviceResult.ErrorMessage,
                ValidationErrors = serviceResult.ValidationErrors
            };
            
            if (result.IsSuccess)
            {
                // 儲存後處理
                if (AfterSave != null)
                {
                    await AfterSave(entity);
                }
                return true;
            }
            else
            {
                var errorMsg = !string.IsNullOrEmpty(result.ErrorMessage) 
                    ? result.ErrorMessage 
                    : "儲存失敗";
                await ShowErrorMessage($"{SaveFailureMessage}：{errorMsg}");
                return false;
            }
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"{SaveFailureMessage}：{ex.Message}");
            LogError("GenericSave", ex);
            return false;
        }
    }
    
    // ===== 欄位變更處理 =====
    
    private async Task HandleFieldChanged((string PropertyName, object? Value) fieldChange)
    {
        // 檢查是否是 AutoComplete 欄位，如果是則更新按鈕
        var field = FormFields?.FirstOrDefault(f => f.PropertyName == fieldChange.PropertyName);
        if (field != null && 
            field.FieldType == FormFieldType.AutoComplete && 
            field.ActionButtons != null && 
            field.ActionButtons.Any())
        {
            // 如果欄位值被清空（null 或空字串），同步清空搜尋關鍵字記錄
            if (fieldChange.Value == null || string.IsNullOrEmpty(fieldChange.Value.ToString()))
            {
                _lastSearchTerms[fieldChange.PropertyName] = string.Empty;
            }
            
            // 重新處理該欄位的 ActionButtons
            field.ActionButtons = ProcessActionButtonsForAutoComplete(field);
            StateHasChanged(); // 觸發 UI 更新
        }
        
        if (OnFieldChanged != null)
        {
            await OnFieldChanged(fieldChange);
        }
    }
    
    // ===== AutoComplete 智能處理 =====
    
    /// <summary>
    /// 處理已處理的表單欄位，包含 AutoComplete 智能功能
    /// </summary>
    private List<FormFieldDefinition> GetProcessedFormFields()
    {
        var processedFields = new List<FormFieldDefinition>();
        
        foreach (var field in FormFields)
        {
            var processedField = new FormFieldDefinition
            {
                PropertyName = field.PropertyName,
                Label = field.Label,
                FieldType = field.FieldType,
                Placeholder = field.Placeholder,
                HelpText = field.HelpText,
                IsRequired = field.IsRequired,
                IsReadOnly = field.IsReadOnly,
                IsDisabled = field.IsDisabled,
                CssClass = field.CssClass,
                ContainerCssClass = field.ContainerCssClass,
                Min = field.Min,
                Max = field.Max,
                Step = field.Step,
                MinLength = field.MinLength,
                MaxLength = field.MaxLength,
                Rows = field.Rows,
                Options = field.Options,
                AutoCompleteDelayMs = field.AutoCompleteDelayMs,
                MinSearchLength = field.MinSearchLength,
                DefaultValue = field.DefaultValue,
                ValidationRules = field.ValidationRules,
                Order = field.Order,
                GroupName = field.GroupName,
                ActionButtons = field.ActionButtons
            };
            
            // 如果是 AutoComplete 欄位，包裝搜尋函式以支援智能預填
            if (field.FieldType == FormFieldType.AutoComplete)
            {
                if (field.SearchFunction != null)
                {
                    // 使用自訂搜尋函式
                    var originalSearchFunction = field.SearchFunction;
                    processedField.SearchFunction = async (searchTerm) =>
                    {
                        // 記錄搜尋關鍵字
                        _lastSearchTerms[field.PropertyName] = searchTerm ?? string.Empty;
                        
                        // 調用原始搜尋函式
                        return await originalSearchFunction(searchTerm ?? string.Empty);
                    };
                }
                else if (AutoCompleteCollections?.ContainsKey(field.PropertyName) == true)
                {
                    // 使用自動搜尋集合
                    processedField.SearchFunction = CreateAutoSearchFunction(field.PropertyName);
                }
                
                // 處理智能按鈕
                if (field.ActionButtons != null && field.ActionButtons.Any())
                {
                    processedField.ActionButtons = ProcessActionButtonsForAutoComplete(field);
                }
            }
            
            processedFields.Add(processedField);
        }
        
        return processedFields;
    }
    
    /// <summary>
    /// 處理 AutoComplete 欄位的操作按鈕，支援智能預填和分離的新增/編輯按鈕
    /// </summary>
    private List<FieldActionButton> ProcessActionButtonsForAutoComplete(FormFieldDefinition field)
    {
        var processedButtons = new List<FieldActionButton>();
        
        // 智能按鈕選擇：根據輸入值是否存在於資料庫決定顯示哪個按鈕
        var searchTerm = _lastSearchTerms.GetValueOrDefault(field.PropertyName, string.Empty);
        
        // 先檢查實體欄位的實際值，如果為空則確保 searchTerm 也為空
        var currentValue = GetEntityPropertyValue(Entity, field.PropertyName);
        var currentId = currentValue as int?;
        
        // 如果實體值為空或 0，強制清空 searchTerm（避免殘留舊關鍵字）
        if (currentId == null || currentId.Value <= 0)
        {
            searchTerm = string.Empty;
            _lastSearchTerms[field.PropertyName] = string.Empty;
        }
        // 如果 searchTerm 為空但實體有值（編輯模式），從 AutoComplete 集合中找出對應的顯示名稱
        else if (string.IsNullOrWhiteSpace(searchTerm) && 
            Entity != null && 
            AutoCompleteCollections?.ContainsKey(field.PropertyName) == true)
        {
            if (currentId.HasValue && currentId.Value > 0)
            {
                var availableEntities = AutoCompleteCollections[field.PropertyName];
                var displayProperty = AutoCompleteDisplayProperties?.GetValueOrDefault(field.PropertyName, "Name") ?? "Name";
                
                // 根據 ID 找出對應的實體
                var matchedByIdEntity = availableEntities.FirstOrDefault(e => 
                {
                    var idValue = GetPropertyValue(e, "Id") as int?;
                    return idValue == currentId.Value;
                });
                
                if (matchedByIdEntity != null)
                {
                    // 取得顯示名稱並存入 _lastSearchTerms
                    var displayValue = GetPropertyValue(matchedByIdEntity, displayProperty)?.ToString();
                    if (!string.IsNullOrWhiteSpace(displayValue))
                    {
                        searchTerm = displayValue;
                        _lastSearchTerms[field.PropertyName] = displayValue;
                    }
                }
            }
        }
        
        bool entityExists = false;
        object? matchedEntity = null;
        
        // 檢查輸入值是否存在於 AutoComplete 集合中
        if (AutoCompleteCollections?.ContainsKey(field.PropertyName) == true && 
            !string.IsNullOrWhiteSpace(searchTerm))
        {
            var availableEntities = AutoCompleteCollections[field.PropertyName];
            var displayProperty = AutoCompleteDisplayProperties?.GetValueOrDefault(field.PropertyName, "Name") ?? "Name";
            matchedEntity = FindMatchingEntity(availableEntities, displayProperty, searchTerm);
            entityExists = matchedEntity != null;
        }
        
        foreach (var button in field.ActionButtons!)
        {
            // 智能過濾：如果實體存在，只保留「編輯」按鈕；否則只保留「新增」按鈕
            if (entityExists && button.Text == "新增")
            {
                continue; // 實體存在時跳過新增按鈕
            }
            if (!entityExists && button.Text == "編輯")
            {
                continue; // 實體不存在時跳過編輯按鈕
            }
            
            var processedButton = new FieldActionButton
            {
                Text = button.Text,
                Variant = button.Variant,
                Size = button.Size,
                IconClass = button.IconClass,
                Title = button.Title,
                IsDisabled = button.IsDisabled
            };
            
            // 如果是新增按鈕且有預填器，包裝點擊事件以支援智能預填
            if (button.Text == "新增" && 
                AutoCompletePrefillers?.ContainsKey(field.PropertyName) == true &&
                button.OnClick != null)
            {
                var originalOnClick = button.OnClick;
                processedButton.OnClick = async () =>
                {
                    // 取得預填值
                    var searchTerm = _lastSearchTerms.GetValueOrDefault(field.PropertyName, string.Empty);
                    if (!string.IsNullOrWhiteSpace(searchTerm))
                    {
                        var prefilledValues = AutoCompletePrefillers[field.PropertyName](searchTerm);
                        
                        // 如果有對應的 Modal 管理器，使用智能開啟
                        if (ModalManagers?.ContainsKey(field.PropertyName) == true)
                        {
                            var modalManager = ModalManagers[field.PropertyName];
                            
                            // 使用反射調用 OpenModalWithPrefilledValuesAsync
                            var openMethod = modalManager.GetType().GetMethod("OpenModalWithPrefilledValuesAsync");
                            if (openMethod != null)
                            {
                                var task = (Task?)openMethod.Invoke(modalManager, new object[] { null!, prefilledValues });
                                if (task != null)
                                {
                                    await task;
                                    return;
                                }
                            }
                        }
                    }
                    
                    // 否則使用原始點擊事件
                    await originalOnClick();
                };
            }
            // 如果是編輯按鈕，包裝點擊事件以支援智能編輯
            else if (button.Text == "編輯" && button.OnClick != null)
            {
                var capturedMatchedEntity = matchedEntity; // 捕獲外層已找到的實體
                var originalOnClick = button.OnClick;
                processedButton.OnClick = async () =>
                {
                    // 使用已找到的匹配實體
                    if (ModalManagers?.ContainsKey(field.PropertyName) == true && capturedMatchedEntity != null)
                    {
                        var modalManager = ModalManagers[field.PropertyName];
                        
                        // 取得實體 ID 並開啟編輯模式
                        var entityIdValue = GetPropertyValue(capturedMatchedEntity, "Id") as int?;
                        if (entityIdValue.HasValue)
                        {
                            var openMethod = modalManager.GetType().GetMethod("OpenModalAsync");
                            if (openMethod != null)
                            {
                                var task = (Task?)openMethod.Invoke(modalManager, new object[] { entityIdValue.Value });
                                if (task != null)
                                {
                                    await task;
                                    return;
                                }
                            }
                        }
                    }
                    
                    // 如果沒有匹配實體或開啟失敗，使用原始點擊事件
                    await originalOnClick();
                };
            }
            else
            {
                processedButton.OnClick = button.OnClick;
            }
            
            processedButtons.Add(processedButton);
        }
        
        return processedButtons;
    }
    
    /// <summary>
    /// 為指定屬性建立自動搜尋函式
    /// </summary>
    private Func<string, Task<List<SelectOption>>> CreateAutoSearchFunction(string propertyName)
    {
        return async (searchTerm) =>
        {
            try
            {
                await Task.Delay(1); // 模擬異步操作
                
                // 記錄搜尋關鍵字
                _lastSearchTerms[propertyName] = searchTerm ?? string.Empty;
                
                if (!AutoCompleteCollections!.ContainsKey(propertyName))
                {
                    return new List<SelectOption>();
                }
                
                var collection = AutoCompleteCollections[propertyName];
                var displayProperty = AutoCompleteDisplayProperties?.GetValueOrDefault(propertyName, "Name") ?? "Name";
                var valueProperty = AutoCompleteValueProperties?.GetValueOrDefault(propertyName, "Id") ?? "Id";
                var maxResults = AutoCompleteMaxResults?.GetValueOrDefault(propertyName, 100) ?? 100;
                
                var filteredResults = collection
                    .Where(item => 
                    {
                        if (string.IsNullOrEmpty(searchTerm))
                            return true;
                            
                        var displayValue = GetPropertyValue(item, displayProperty)?.ToString() ?? string.Empty;
                        return displayValue.Contains(searchTerm, StringComparison.OrdinalIgnoreCase);
                    })
                    .Take(maxResults)
                    .Select(item => new SelectOption
                    {
                        Text = GetPropertyValue(item, displayProperty)?.ToString() ?? string.Empty,
                        Value = GetPropertyValue(item, valueProperty)?.ToString() ?? string.Empty
                    })
                    .ToList();
                
                return filteredResults;
            }
            catch (Exception ex)
            {
                LogError($"AutoSearch_{propertyName}", ex);
                return new List<SelectOption>();
            }
        };
    }
    
    /// <summary>
    /// 在集合中尋找匹配的實體
    /// </summary>
    /// <param name="entities">實體集合</param>
    /// <param name="propertyName">要比較的屬性名稱</param>
    /// <param name="searchValue">搜尋值</param>
    /// <returns>匹配的實體，如果找不到則返回 null</returns>
    private object? FindMatchingEntity(IEnumerable<object> entities, string propertyName, string searchValue)
    {
        try
        {
            return entities.FirstOrDefault(entity =>
            {
                var propertyValue = GetPropertyValue(entity, propertyName)?.ToString();
                return string.Equals(propertyValue, searchValue, StringComparison.OrdinalIgnoreCase);
            });
        }
        catch
        {
            return null;
        }
    }
    
    /// <summary>
    /// 使用反射取得物件屬性值
    /// </summary>
    private object? GetPropertyValue(object obj, string propertyName)
    {
        try
        {
            var property = obj.GetType().GetProperty(propertyName);
            return property?.GetValue(obj);
        }
        catch
        {
            return null;
        }
    }
    
    /// <summary>
    /// 更新所有帶有 ActionButtons 的欄位，確保按鈕狀態與實體資料同步
    /// </summary>
    private void UpdateAllActionButtons()
    {
        try
        {
            // 只有在實體資料存在且有 ModalManagers 和 FormFields 時才執行更新
            if (Entity == null || ModalManagers == null || !ModalManagers.Any() || FormFields == null || !FormFields.Any())
                return;

            // 直接更新原始的 FormFields，而不是 GetProcessedFormFields 的結果
            var fieldsWithButtons = FormFields.Where(f => f.ActionButtons != null && f.ActionButtons.Any()).ToList();
            
            foreach (var field in fieldsWithButtons)
            {
                // 從 ModalManagers 字典中找到對應的管理器並更新按鈕
                if (ModalManagers.ContainsKey(field.PropertyName))
                {
                    var modalManager = ModalManagers[field.PropertyName];
                    
                    // 取得當前實體對應屬性的值
                    var currentValue = GetEntityPropertyValue(Entity, field.PropertyName);
                    var intValue = currentValue as int?;
                    
                    // 使用反射調用 UpdateFieldActionButtons 方法
                    var updateMethod = modalManager?.GetType().GetMethod("UpdateFieldActionButtons");
                    if (updateMethod != null && modalManager != null)
                    {
                        // 直接傳入原始的 FormFields，而不是處理過的
                        updateMethod.Invoke(modalManager, new object?[] { FormFields, field.PropertyName, intValue });
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _ = Task.Run(() => LogError("UpdateAllActionButtons", ex));
        }
    }
    
    /// <summary>
    /// 取得實體屬性值的輔助方法
    /// </summary>
    private object? GetEntityPropertyValue(object obj, string propertyName)
    {
        try
        {
            var property = obj.GetType().GetProperty(propertyName);
            return property?.GetValue(obj);
        }
        catch
        {
            return null;
        }
    }
    
    #region 記錄導航處理
    
    /// <summary>
    /// 載入導航狀態（上一筆和下一筆的 ID，支援循環導航）
    /// 新增模式：只載入最後一筆 ID
    /// 編輯模式：載入完整導航資訊
    /// </summary>
    private async Task LoadNavigationStateAsync()
    {
        // 使用 _currentId（導航時的實際 ID）或 Id（參數）
        var currentId = _currentId ?? Id;
        
        //  重要修正：即使在新增模式（currentId 為 null）也需要載入 _lastRecordId
        // 因為返回編輯按鈕需要 _lastRecordId 來判斷是否顯示
        if (!EnableNavigation || Service == null)
        {
            _previousId = null;
            _nextId = null;
            _firstId = null;
            _lastRecordId = null;
            return;
        }
        
        try
        {
            // 使用反射調用服務的導航方法
            var serviceType = Service.GetType();
            
            // 新增模式：只載入最後一筆 ID（用於返回編輯按鈕）
            if (!currentId.HasValue)
            {
                var getLastMethod = serviceType.GetMethod("GetLastIdAsync");
                if (getLastMethod != null)
                {
                    var lastTask = getLastMethod.Invoke(Service, new object[] { }) as Task<int?>;
                    if (lastTask != null)
                    {
                        _lastRecordId = await lastTask;
                    }
                }
                
                // 清空其他導航狀態
                _previousId = null;
                _nextId = null;
                _firstId = null;
                return;
            }
            
            // 編輯模式：載入完整導航資訊
            var getPreviousMethod = serviceType.GetMethod("GetPreviousIdAsync");
            var getNextMethod = serviceType.GetMethod("GetNextIdAsync");
            var getFirstMethod = serviceType.GetMethod("GetFirstIdAsync");
            var getLastMethod2 = serviceType.GetMethod("GetLastIdAsync");
            
            // 載入上一筆 ID
            if (getPreviousMethod != null)
            {
                var previousTask = getPreviousMethod.Invoke(Service, new object[] { currentId.Value }) as Task<int?>;
                if (previousTask != null)
                {
                    _previousId = await previousTask;
                }
            }
            
            // 載入下一筆 ID
            if (getNextMethod != null)
            {
                var nextTask = getNextMethod.Invoke(Service, new object[] { currentId.Value }) as Task<int?>;
                if (nextTask != null)
                {
                    _nextId = await nextTask;
                }
            }
            
            // 載入第一筆 ID（用於循環導航）
            if (getFirstMethod != null)
            {
                var firstTask = getFirstMethod.Invoke(Service, new object[] { }) as Task<int?>;
                if (firstTask != null)
                {
                    _firstId = await firstTask;
                }
            }
            
            // 載入最後一筆 ID（用於循環導航）
            if (getLastMethod2 != null)
            {
                var lastTask = getLastMethod2.Invoke(Service, new object[] { }) as Task<int?>;
                if (lastTask != null)
                {
                    _lastRecordId = await lastTask;
                }
            }
            
            // 循環邏輯：如果沒有上一筆，設為最後一筆；如果沒有下一筆，設為第一筆
            if (!_previousId.HasValue && _lastRecordId.HasValue)
            {
                _previousId = _lastRecordId.Value;
            }
            
            if (!_nextId.HasValue && _firstId.HasValue)
            {
                _nextId = _firstId.Value;
            }
        }
        catch (Exception ex)
        {
            LogError("LoadNavigationStateAsync", ex);
            _previousId = null;
            _nextId = null;
            _firstId = null;
            _lastRecordId = null;
        }
    }
    
    /// <summary>
    /// 處理返回編輯按鈕點擊（新增模式專用，返回到最後一筆記錄）
    /// </summary>
    private async Task HandleReturnToLast()
    {
        if (IsLoading || IsSubmitting) return;
        
        try
        {
            if (_lastRecordId.HasValue)
            {
                await NavigateToRecordAsync(_lastRecordId.Value);
            }
            else
            {
                await ShowErrorMessage($"找不到最後一筆{EntityName}");
            }
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"返回編輯{EntityName}時發生錯誤");
            LogError("HandleReturnToLast", ex);
        }
    }
    
    /// <summary>
    /// 處理上一筆按鈕點擊（支援循環導航）
    /// </summary>
    private async Task HandlePrevious()
    {
        if (IsLoading || IsSubmitting) return;
        
        try
        {
            if (_previousId.HasValue)
            {
                await NavigateToRecordAsync(_previousId.Value);
            }
            else
            {
                await ShowErrorMessage($"無法切換到上一筆{EntityName}");
            }
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"切換到上一筆{EntityName}時發生錯誤");
            LogError("HandlePrevious", ex);
        }
    }
    
    /// <summary>
    /// 處理下一筆按鈕點擊（支援循環導航）
    /// </summary>
    private async Task HandleNext()
    {
        if (IsLoading || IsSubmitting) return;
        
        try
        {
            if (_nextId.HasValue)
            {
                await NavigateToRecordAsync(_nextId.Value);
            }
            else
            {
                await ShowErrorMessage($"無法切換到下一筆{EntityName}");
            }
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"切換到下一筆{EntityName}時發生錯誤");
            LogError("HandleNext", ex);
        }
    }
    
    /// <summary>
    /// 導航到指定的記錄
    /// </summary>
    private async Task NavigateToRecordAsync(int targetId)
    {
        try
        {
            //  關鍵修復：設置導航標記，防止 LoadAllData 呼叫 DataLoader 覆蓋資料
            _isNavigating = true;
            
            //  優化：不使用 IsLoading，避免顯示載入動畫造成閃爍
            // IsLoading = true;
            // StateHasChanged();  // 移除此處的 StateHasChanged，減少重繪次數
            
            //  關鍵修復：使用內部變數 _currentId 追蹤導航後的 ID
            // 因為 Id 是 [Parameter]，無法在組件內部直接修改
            _lastId = targetId;
            _currentId = targetId;  // 使用內部變數追蹤
            
            // 使用 Service 直接載入新的實體資料（不依賴 DataLoader）
            if (Service != null)
            {
                // 使用反射調用 Service.GetByIdAsync 方法
                var serviceType = Service.GetType();
                var getByIdMethod = serviceType.GetMethod("GetByIdAsync");
                
                if (getByIdMethod != null)
                {
                    var getByIdTask = getByIdMethod.Invoke(Service, new object[] { targetId }) as Task<TEntity>;
                    if (getByIdTask != null)
                    {
                        var loadedEntity = await getByIdTask;
                        if (loadedEntity != null)
                        {
                            //  優化：先完成所有資料更新，最後才觸發一次 UI 重繪
                            Entity = loadedEntity;
                            editContext = new EditContext(Entity);
                            
                            //  觸發 IdChanged 事件，通知父組件 ID 已變更（雙向綁定）
                            if (IdChanged.HasDelegate)
                            {
                                await IdChanged.InvokeAsync(targetId);
                            }
                            
                            //  重要：不需要遞增 _autoCompleteVersion
                            // 因為 @key="@(Entity?.Id ?? 0)"，Entity.Id 變化時組件會自動重新創建
                            
                            //  重要：不呼叫 AdditionalDataLoader
                            // 導航時資料已經載入，重複呼叫可能導致 JavaScript 重複初始化錯誤
                            // AdditionalDataLoader 主要用於 Modal 首次開啟時載入選項資料
                            
                            // 更新 ActionButtons（基於新的 Entity 資料）
                            UpdateAllActionButtons();
                            
                            // 重新載入狀態訊息
                            await LoadStatusMessageData();
                            
                            // 重新載入導航狀態（基於新的 Id）
                            await LoadNavigationStateAsync();
                            
                            //  新增：觸發實體載入完成事件，通知父組件重新載入明細資料
                            if (OnEntityLoaded.HasDelegate)
                            {
                                await OnEntityLoaded.InvokeAsync(targetId);
                            }
                            
                            //  優化：所有資料更新完成後，只觸發一次 UI 重繪
                            StateHasChanged();
                        }
                        else
                        {
                            await ShowErrorMessage($"找不到指定的{EntityName}");
                        }
                    }
                }
            }
            else if (DataLoader != null)
            {
                // 後備方案：如果沒有 Service，嘗試使用 DataLoader
                // 但這可能不會正確載入新 ID 的資料
                await LoadAllData();
            }
        }
        catch (Exception ex)
        {
            await ShowErrorMessage($"導航時發生錯誤：{ex.Message}");
            LogError("NavigateToRecordAsync", ex);
        }
        finally
        {
            // IsLoading = false;  // 不使用 IsLoading
            _isNavigating = false;  //  清除導航標記
            // StateHasChanged();  // 移除此處的 StateHasChanged，已在成功載入後觸發
        }
    }
    
    /// <summary>
    /// 取得上一筆按鈕的提示文字
    /// </summary>
    private string GetPreviousButtonTitle()
    {
        if (!_previousId.HasValue)
            return $"沒有上一筆{EntityName}";
        
        // 判斷是否為循環導航（當前是第一筆，上一筆是最後一筆）
        if (_firstId.HasValue && Id.HasValue && Id.Value == _firstId.Value)
            return $"切換到最後一筆{EntityName}（循環）";
        
        return $"切換到上一筆{EntityName}";
    }
    
    /// <summary>
    /// 取得下一筆按鈕的提示文字
    /// </summary>
    private string GetNextButtonTitle()
    {
        if (!_nextId.HasValue)
            return $"沒有下一筆{EntityName}";
        
        // 判斷是否為循環導航（當前是最後一筆，下一筆是第一筆）
        if (_lastRecordId.HasValue && Id.HasValue && Id.Value == _lastRecordId.Value)
            return $"切換到第一筆{EntityName}（循環）";
        
        return $"切換到下一筆{EntityName}";
    }
    
    #endregion
    
    // ===== 清理資源 =====
    
    // Dispose 方法已移除，資源清理由 BaseModalComponent 自動處理
}

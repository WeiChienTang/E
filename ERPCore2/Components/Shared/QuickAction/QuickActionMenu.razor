@using System.Reflection.Metadata
@inject IJSRuntime JSRuntime
@inject IStringLocalizer<SharedResource> L
@implements IDisposable

@* 快速功能表 - 右下角浮動按鈕 *@

@* 遮罩層（點擊關閉選單） - 必須在最前面渲染 *@
@if (isExpanded)
{
    <div class="quick-action-backdrop" @onclick="CloseMenu"></div>
}

<div class="quick-action-menu @(isExpanded ? "expanded" : "")">
    
    @* 主按鈕 *@
    <button class="quick-action-main-btn" 
            @onclick="ToggleMenu" 
            title="@L["QuickAction.MenuTooltip"]"
            aria-label="@L["QuickAction.MenuAriaLabel"]"
            aria-expanded="@isExpanded">
        <span class="bi @(isExpanded ? "bi-x-lg" : "bi-lightning-charge-fill")"></span>
    </button>

    @* 展開的功能選單 *@
    @if (isExpanded)
    {
        <div class="quick-action-items">
            
            @* 頁面搜尋 *@
            <button class="quick-action-item" 
                    @onclick="HandlePageSearchClick"
                    title="@L["QuickAction.PageSearchTooltip"]">
                <span class="bi bi-search"></span>
                <span class="quick-action-label">@L["QuickAction.PageSearch"]</span>
            </button>

            @* 報表搜尋 *@
            <button class="quick-action-item" 
                    @onclick="HandleReportSearchClick"
                    title="@L["QuickAction.ReportSearchTooltip"]">
                <span class="bi bi-printer"></span>
                <span class="quick-action-label">@L["QuickAction.ReportSearch"]</span>
            </button>

            @* 快捷鍵說明 *@
            <button class="quick-action-item" 
                    @onclick="HandleShortcutKeysClick"
                    title="@L["QuickAction.ShortcutKeys"]">
                <span class="bi bi-keyboard"></span>
                <span class="quick-action-label">@L["QuickAction.ShortcutKeys"]</span>
            </button>

            @* 預留：通知中心 *@
            @if (showNotifications)
            {
                <button class="quick-action-item" 
                        @onclick="HandleNotificationsClick"
                        title="@L["QuickAction.NotificationsTitle"]">
                    <span class="bi bi-bell"></span>
                    <span class="quick-action-label">@L["QuickAction.Notifications"]</span>
                    @if (notificationCount > 0)
                    {
                        <span class="quick-action-badge">@notificationCount</span>
                    }
                </button>
            }

            @* 預留：最近頁面 *@
            @if (showRecentPages)
            {
                <button class="quick-action-item" 
                        @onclick="HandleRecentPagesClick"
                        title="@L["QuickAction.RecentPages"]">
                    <span class="bi bi-clock-history"></span>
                    <span class="quick-action-label">@L["QuickAction.RecentPages"]</span>
                </button>
            }

            @* 預留：快速設定 *@
            @if (showSettings)
            {
                <button class="quick-action-item"
                        @onclick="HandleSettingsClick"
                        title="@L["QuickAction.SettingsTitle"]">
                    <span class="bi bi-gear"></span>
                    <span class="quick-action-label">@L["QuickAction.Settings"]</span>
                </button>
            }

            @* 關於本系統 *@
            <button class="quick-action-item"
                    @onclick="HandleAboutClick"
                    title="@L["QuickAction.AboutTitle"]">
                <span class="bi bi-info-circle"></span>
                <span class="quick-action-label">@L["QuickAction.About"]</span>
            </button>

        </div>
    }

</div>

@* 關於 Modal *@
<AboutModalComponent IsVisible="@showAboutModal"
                    IsVisibleChanged="@((bool v) => showAboutModal = v)" />

@code {
    // ===== 參數 =====
    
    /// <summary>
    /// 當點擊頁面搜尋時觸發
    /// </summary>
    [Parameter]
    public EventCallback OnPageSearchClick { get; set; }

    /// <summary>
    /// 當點擊快捷鍵說明時觸發
    /// </summary>
    [Parameter]
    public EventCallback OnShortcutKeysClick { get; set; }

    /// <summary>
    /// 當點擊報表搜尋時觸發
    /// </summary>
    [Parameter]
    public EventCallback OnReportSearchClick { get; set; }

    /// <summary>
    /// 是否顯示通知功能（預留）
    /// </summary>
    [Parameter]
    public bool showNotifications { get; set; } = false;

    /// <summary>
    /// 是否顯示最近頁面功能（預留）
    /// </summary>
    [Parameter]
    public bool showRecentPages { get; set; } = false;

    /// <summary>
    /// 是否顯示設定功能（預留）
    /// </summary>
    [Parameter]
    public bool showSettings { get; set; } = false;

    // ===== 狀態 =====

    private bool isExpanded = false;
    private int notificationCount = 0; // 預留：通知數量
    private bool showAboutModal = false;
    
    // ESC 鍵支援
    private DotNetObjectReference<QuickActionMenu>? _escKeyDotNetRef;
    private bool _isEscKeyListenerActive = false;
    private bool _isDisposed = false;
    private readonly object _escKeyLock = new object();

    // ===== 生命週期 =====

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // 註冊 Alt+Q 快捷鍵來開關快速功能表
                await JSRuntime.InvokeVoidAsync("eval", @"
                    document.addEventListener('keydown', function(e) {
                        if (e.altKey && e.key.toLowerCase() === 'q') {
                            e.preventDefault();
                            const btn = document.querySelector('.quick-action-main-btn');
                            if (btn) btn.click();
                        }
                    });
                ");
            }
            catch
            {
                // 忽略註冊快捷鍵失敗
            }
        }
        
        // ESC 鍵監聽器管理
        if (isExpanded)
        {
            bool shouldSetup;
            lock (_escKeyLock)
            {
                shouldSetup = !_isEscKeyListenerActive;
            }
            
            if (shouldSetup)
            {
                await SetupEscKeyListenerAsync();
            }
        }
        else
        {
            bool shouldCleanup;
            lock (_escKeyLock)
            {
                shouldCleanup = _isEscKeyListenerActive;
            }
            
            if (shouldCleanup)
            {
                await CleanupEscKeyListenerAsync();
            }
        }
    }

    // ===== 事件處理 =====

    /// <summary>
    /// 切換選單展開/收起
    /// </summary>
    private void ToggleMenu()
    {
        isExpanded = !isExpanded;
    }

    /// <summary>
    /// 關閉選單
    /// </summary>
    private void CloseMenu()
    {
        isExpanded = false;
    }

    /// <summary>
    /// 處理頁面搜尋點擊
    /// </summary>
    private async Task HandlePageSearchClick()
    {
        CloseMenu();
        if (OnPageSearchClick.HasDelegate)
        {
            await OnPageSearchClick.InvokeAsync();
        }
    }

    private async Task HandleShortcutKeysClick()
    {
        CloseMenu();
        if (OnShortcutKeysClick.HasDelegate)
        {
            await OnShortcutKeysClick.InvokeAsync();
        }
    }

    /// <summary>
    /// 處理報表搜尋點擊
    /// </summary>
    private async Task HandleReportSearchClick()
    {
        CloseMenu();
        if (OnReportSearchClick.HasDelegate)
        {
            await OnReportSearchClick.InvokeAsync();
        }
    }

    /// <summary>
    /// 處理通知點擊（預留）
    /// </summary>
    private async Task HandleNotificationsClick()
    {
        CloseMenu();
        await JSRuntime.InvokeVoidAsync("alert", L["QuickAction.NotificationsDev"].ToString());
    }

    /// <summary>
    /// 處理最近頁面點擊（預留）
    /// </summary>
    private async Task HandleRecentPagesClick()
    {
        CloseMenu();
        await JSRuntime.InvokeVoidAsync("alert", L["QuickAction.RecentPagesDev"].ToString());
    }

    /// <summary>
    /// 處理設定點擊（預留）
    /// </summary>
    private async Task HandleSettingsClick()
    {
        CloseMenu();
        await JSRuntime.InvokeVoidAsync("alert", L["QuickAction.SettingsDev"].ToString());
    }

    /// <summary>
    /// 處理關於點擊
    /// </summary>
    private void HandleAboutClick()
    {
        CloseMenu();
        showAboutModal = true;
    }

    // ===== 公開方法 =====

    /// <summary>
    /// 從外部開啟選單
    /// </summary>
    public void Open()
    {
        isExpanded = true;
        StateHasChanged();
    }

    /// <summary>
    /// 從外部關閉選單
    /// </summary>
    public void Close()
    {
        isExpanded = false;
        StateHasChanged();
    }

    // ===== ESC 鍵支援方法 =====

    private async Task SetupEscKeyListenerAsync()
    {
        try
        {
            lock (_escKeyLock)
            {
                if (_isEscKeyListenerActive && _escKeyDotNetRef != null)
                {
                    return;
                }
                
                _isEscKeyListenerActive = true;
            }
            
            lock (_escKeyLock)
            {
                _escKeyDotNetRef = DotNetObjectReference.Create(this);
            }
            
            await JSRuntime.InvokeVoidAsync("setupEscKeyListener", _escKeyDotNetRef);
        }
        catch (Exception ex)
        {
            lock (_escKeyLock)
            {
                _isEscKeyListenerActive = false;
            }
            LogError("SetupEscKeyListener", ex);
        }
    }
    
    private async Task CleanupEscKeyListenerAsync()
    {
        DotNetObjectReference<QuickActionMenu>? refToDispose = null;
        
        lock (_escKeyLock)
        {
            if (!_isEscKeyListenerActive)
            {
                return;
            }
            
            _isEscKeyListenerActive = false;
            refToDispose = _escKeyDotNetRef;
            _escKeyDotNetRef = null;
        }
        
        try
        {
            await JSRuntime.InvokeVoidAsync("cleanupEscKeyListener");
            await Task.Delay(200);
            
            if (refToDispose != null)
            {
                try
                {
                    refToDispose.Dispose();
                }
                catch (ObjectDisposedException)
                {
                    // 對象已被釋放，這是正常的
                }
                catch (Exception ex)
                {
                    LogError($"DotNetObjectReference dispose warning (safe to ignore): {ex.Message}", ex);
                }
            }
        }
        catch (JSDisconnectedException)
        {
            // Blazor 連接已斷開，這是正常的
        }
        catch (TaskCanceledException)
        {
            // 任務被取消，這是正常的
        }
        catch (Exception ex)
        {
            LogError("CleanupEscKeyListener", ex);
        }
    }
    
    [JSInvokable]
    public async Task HandleEscapeKey()
    {
        try
        {
            if (_isDisposed)
            {
                return;
            }
            
            if (isExpanded)
            {
                CloseMenu();
                StateHasChanged();
                await Task.CompletedTask;
            }
        }
        catch (ObjectDisposedException)
        {
            // 忽略已釋放物件的錯誤
        }
        catch (InvalidOperationException)
        {
            // 忽略無效操作錯誤
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"ESC Error: {ex.Message}");
        }
    }
    
    private void LogError(string method, Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"[QuickActionMenu.{method}] 錯誤：{ex.Message}");
    }

    // ===== 資源清理 =====

    public void Dispose()
    {
        try
        {
            DotNetObjectReference<QuickActionMenu>? refToDispose = null;
            
            lock (_escKeyLock)
            {
                _isDisposed = true;
                _isEscKeyListenerActive = false;
                refToDispose = _escKeyDotNetRef;
                _escKeyDotNetRef = null;
            }
            
            refToDispose?.Dispose();
            
            _ = Task.Run(async () =>
            {
                try
                {
                    await CleanupEscKeyListenerAsync();
                }
                catch
                {
                    // 忽略清理過程中的錯誤
                }
            });
        }
        catch
        {
            // 忽略清理過程中的錯誤
        }
    }
}

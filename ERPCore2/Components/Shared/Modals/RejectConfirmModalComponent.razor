@* 
    駁回確認 Modal 組件
    提供審核駁回前的確認對話框，可選填駁回原因
*@
@using ERPCore2.Components.Shared.Buttons
@using ERPCore2.Services
@inject INotificationService NotificationService
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="modal fade @(IsVisible ? "show" : "")" 
     style="display: @(IsVisible ? "block" : "none"); background-color: rgba(0,0,0,0.5);" 
     tabindex="-1" 
     role="dialog"
     @onclick="@HandleBackdropClick">
    
    <div class="modal-dialog modal-dialog-centered" 
         role="document"
         @onclick:stopPropagation="true">
        <div class="modal-content shadow-lg">
            
            @* Header：標題區 *@
            <div class="modal-header bg-danger text-white">
                <h5 class="modal-title fw-bold">
                    <i class="fas fa-times-circle me-2"></i>
                    @Title
                </h5>
                <GenericButtonComponent Type="button" 
                                      CssClass="btn-close btn-close-white" 
                                      OnClick="HandleCancel" 
                                      Title="關閉" />
            </div>
            
            @* Modal Actions - 按鈕區塊 *@
            <div class="modal-footer border-bottom border-top-0 d-flex align-items-center">
                @* 按鈕組靠右對齊 *@
                <div class="d-flex gap-2 ms-auto">
                    <GenericButtonComponent Variant="ButtonVariant.Danger" 
                                          Text="@ConfirmButtonText" 
                                          OnClick="HandleConfirm"
                                          IsDisabled="@IsProcessing"
                                          IsLoading="@IsProcessing"
                                          Title="確認駁回" />
                    <GenericButtonComponent Variant="ButtonVariant.Secondary" 
                                          Text="@CancelButtonText" 
                                          OnClick="HandleCancel"
                                          IsDisabled="@IsProcessing"
                                          Title="取消" />
                </div>
            </div>

            @* Body：駁回原因輸入 *@
            <div class="modal-body p-4">
                <div class="mb-3">                    
                    @if (ShowReasonInput)
                    {
                        <textarea class="form-control" 
                                  rows="4" 
                                  placeholder="請輸入駁回原因..."
                                  @bind="RejectReason"
                                  disabled="@IsProcessing"></textarea>
                        
                        @if (IsReasonRequired && string.IsNullOrWhiteSpace(RejectReason))
                        {
                            <div class="text-danger small mt-1">
                                <i class="fas fa-info-circle me-1"></i>
                                請填寫駁回原因
                            </div>
                        }
                    }
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    // ===== 參數定義 =====
    
    /// <summary>
    /// Modal 是否顯示
    /// </summary>
    [Parameter]
    public bool IsVisible { get; set; }
    
    /// <summary>
    /// Modal 顯示狀態變更事件
    /// </summary>
    [Parameter]
    public EventCallback<bool> IsVisibleChanged { get; set; }
    
    /// <summary>
    /// Modal 標題
    /// </summary>
    [Parameter]
    public string Title { get; set; } = "確認駁回";
    
    /// <summary>
    /// 確認按鈕文字
    /// </summary>
    [Parameter]
    public string ConfirmButtonText { get; set; } = "確認駁回";
    
    /// <summary>
    /// 取消按鈕文字
    /// </summary>
    [Parameter]
    public string CancelButtonText { get; set; } = "取消";
    
    /// <summary>
    /// 是否顯示駁回原因輸入框
    /// </summary>
    [Parameter]
    public bool ShowReasonInput { get; set; } = true;
    
    /// <summary>
    /// 駁回原因是否必填
    /// </summary>
    [Parameter]
    public bool IsReasonRequired { get; set; } = false;
    
    /// <summary>
    /// 駁回原因
    /// </summary>
    [Parameter]
    public string RejectReason { get; set; } = string.Empty;
    
    /// <summary>
    /// 駁回原因變更事件
    /// </summary>
    [Parameter]
    public EventCallback<string> RejectReasonChanged { get; set; }
    
    /// <summary>
    /// 確認事件（返回駁回原因）
    /// </summary>
    [Parameter]
    public EventCallback<string> OnConfirm { get; set; }
    
    /// <summary>
    /// 取消事件
    /// </summary>
    [Parameter]
    public EventCallback OnCancel { get; set; }
    
    // ===== 內部狀態 =====
    private bool IsProcessing { get; set; } = false;
    
    // ===== ESC 鍵支援 =====
    private DotNetObjectReference<RejectConfirmModalComponent>? _escKeyDotNetRef;
    private bool _isEscKeyListenerActive = false;
    private bool _isDisposed = false;
    private readonly object _escKeyLock = new object();

    // ===== 生命週期方法 =====

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsVisible)
        {
            // 只在狀態真正改變時設置監聽器
            bool shouldSetup;
            lock (_escKeyLock)
            {
                shouldSetup = !_isEscKeyListenerActive;
            }
            
            if (shouldSetup)
            {
                await SetupEscKeyListenerAsync();
            }
        }
        else
        {
            // 只在有監聽器時才清理
            bool shouldCleanup;
            lock (_escKeyLock)
            {
                shouldCleanup = _isEscKeyListenerActive;
            }
            
            if (shouldCleanup)
            {
                await CleanupEscKeyListenerAsync();
            }
        }
    }

    // ===== 事件處理方法 =====

    /// <summary>
    /// 處理確認按鈕點擊
    /// </summary>
    private async Task HandleConfirm()
    {
        try
        {
            // 驗證必填欄位
            if (IsReasonRequired && ShowReasonInput && string.IsNullOrWhiteSpace(RejectReason))
            {
                await NotificationService.ShowWarningAsync("請填寫駁回原因");
                return;
            }
            
            IsProcessing = true;
            StateHasChanged();
            
            if (OnConfirm.HasDelegate)
            {
                await OnConfirm.InvokeAsync(RejectReason);
            }
            
            // 關閉 Modal
            await CloseModal();
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"確認駁回時發生錯誤：{ex.Message}");
        }
        finally
        {
            IsProcessing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// 處理取消按鈕點擊
    /// </summary>
    private async Task HandleCancel()
    {
        try
        {
            if (IsProcessing) return;
            
            await CloseModal();
            
            if (OnCancel.HasDelegate)
            {
                await OnCancel.InvokeAsync();
            }
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"取消操作時發生錯誤：{ex.Message}");
        }
    }

    /// <summary>
    /// 處理背景點擊
    /// </summary>
    private async Task HandleBackdropClick()
    {
        if (!IsProcessing)
        {
            await HandleCancel();
        }
    }
    
    /// <summary>
    /// 關閉 Modal
    /// </summary>
    private async Task CloseModal()
    {
        // 重置駁回原因
        RejectReason = string.Empty;
        
        if (IsVisibleChanged.HasDelegate)
        {
            await IsVisibleChanged.InvokeAsync(false);
        }
    }

    // ===== ESC 鍵支援方法 =====

    /// <summary>
    /// 設置 ESC 鍵監聽器，當按下 ESC 鍵時自動關閉 Modal
    /// </summary>
    private async Task SetupEscKeyListenerAsync()
    {
        try
        {
            lock (_escKeyLock)
            {
                // 如果已經設置過，不重複設置
                if (_isEscKeyListenerActive && _escKeyDotNetRef != null)
                {
                    return;
                }
                
                _isEscKeyListenerActive = true;
            }
            
            // 創建新的 DotNetObjectReference
            lock (_escKeyLock)
            {
                _escKeyDotNetRef = DotNetObjectReference.Create(this);
            }
            
            await JSRuntime.InvokeVoidAsync("setupEscKeyListener", _escKeyDotNetRef);
        }
        catch (Exception ex)
        {
            lock (_escKeyLock)
            {
                _isEscKeyListenerActive = false;
            }
            LogError("SetupEscKeyListener", ex);
        }
    }
    
    /// <summary>
    /// 清理 ESC 鍵事件監聽器
    /// </summary>
    private async Task CleanupEscKeyListenerAsync()
    {
        DotNetObjectReference<RejectConfirmModalComponent>? refToDispose = null;
        
        lock (_escKeyLock)
        {
            // 如果已經清理過，不重複清理
            if (!_isEscKeyListenerActive)
            {
                return;
            }
            
            _isEscKeyListenerActive = false;
            refToDispose = _escKeyDotNetRef;
            _escKeyDotNetRef = null;
        }
        
        try
        {
            // 先調用 JavaScript 清理
            await JSRuntime.InvokeVoidAsync("cleanupEscKeyListener");
            
            // 給 JavaScript 更多時間完成清理
            await Task.Delay(200);
            
            // 在鎖外釋放資源，避免死鎖
            if (refToDispose != null)
            {
                try
                {
                    refToDispose.Dispose();
                }
                catch (ObjectDisposedException)
                {
                    // 對象已被釋放，這是正常的
                }
                catch (Exception ex)
                {
                    // 記錄但不拋出 dispose 錯誤
                    LogError($"DotNetObjectReference dispose warning (safe to ignore): {ex.Message}", ex);
                }
            }
        }
        catch (JSDisconnectedException)
        {
            // Blazor 連接已斷開，這是正常的
        }
        catch (TaskCanceledException)
        {
            // 任務被取消，這是正常的
        }
        catch (Exception ex)
        {
            LogError("CleanupEscKeyListener", ex);
        }
    }
    
    /// <summary>
    /// 處理 ESC 鍵按下事件（由 JavaScript 調用）
    /// </summary>
    [JSInvokable]
    public async Task HandleEscapeKey()
    {
        try
        {
            // 增加額外的安全檢查
            if (_isDisposed)
            {
                return;
            }
            
            if (IsVisible && !IsProcessing)
            {
                await HandleCancel();
            }
        }
        catch (ObjectDisposedException)
        {
            // 忽略已釋放物件的錯誤
        }
        catch (InvalidOperationException)
        {
            // 忽略無效操作錯誤（通常發生在組件已被釋放時）
        }
        catch (Exception ex)
        {
            // 簡化錯誤處理，避免複雜的 JSInterop 調用
            System.Diagnostics.Debug.WriteLine($"ESC Error: {ex.Message}");
            // 不重新拋出例外，避免影響使用者體驗
        }
    }
    
    /// <summary>
    /// 錯誤日誌記錄
    /// </summary>
    private void LogError(string method, Exception ex)
    {
        // 使用系統日誌而非 console 輸出
        System.Diagnostics.Debug.WriteLine($"[RejectConfirmModalComponent.{method}] 錯誤：{ex.Message}");
    }

    // ===== 資源清理 =====

    public void Dispose()
    {
        try
        {
            DotNetObjectReference<RejectConfirmModalComponent>? refToDispose = null;
            
            lock (_escKeyLock)
            {
                // 標記為已釋放
                _isDisposed = true;
                // 標記為已清理，防止重複操作
                _isEscKeyListenerActive = false;
                refToDispose = _escKeyDotNetRef;
                _escKeyDotNetRef = null;
            }
            
            // 同步釋放 DotNetObjectReference（避免重複釋放）
            refToDispose?.Dispose();
            
            // 異步清理事件監聽器，但不等待結果以避免阻塞 Dispose
            _ = Task.Run(async () =>
            {
                try
                {
                    await CleanupEscKeyListenerAsync();
                }
                catch
                {
                    // 忽略清理過程中的錯誤
                }
            });
        }
        catch
        {
            // 忽略清理過程中的錯誤
        }
    }
}

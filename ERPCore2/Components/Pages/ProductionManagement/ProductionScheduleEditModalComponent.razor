@* 可重用的生產排程編輯組件 - 雙表格設計（左側明細、右側排程項目）*@
@using ERPCore2.Components.Shared.UI.Button
@using ERPCore2.Helpers.InteractiveTableComponentHelper
@using ERPCore2.Models.Enums
@using ERPCore2.Models
@inject IProductionScheduleService ProductionScheduleService
@inject IProductionScheduleItemService ProductionScheduleItemService
@inject ICustomerService CustomerService
@inject IEmployeeService EmployeeService
@inject IProductService ProductService
@inject ISalesOrderService SalesOrderService
@inject ISalesOrderDetailService SalesOrderDetailService
@inject INotificationService NotificationService

<GenericEditModalComponent TEntity="ProductionSchedule" 
                          TService="IProductionScheduleService"
                          @ref="editModalComponent"
                          IsVisible="@IsVisible"
                          IsVisibleChanged="@IsVisibleChanged"
                          @bind-Id="@ProductionScheduleId"
                          Service="@ProductionScheduleService"
                          EntityName="生產排程"
                          EntityNamePlural="生產排程"
                          ModalTitle="@(ProductionScheduleId.HasValue ? "編輯生產排程" : "新增生產排程")"
                          Size="GenericEditModalComponent<ProductionSchedule, IProductionScheduleService>.ModalSize.Desktop"
                          UseGenericForm="true"
                          FormFields="@formFields"
                          FormSections="@formSections"
                          AutoCompletePrefillers="@autoCompleteConfig?.Prefillers"
                          AutoCompleteCollections="@autoCompleteConfig?.Collections"
                          AutoCompleteDisplayProperties="@autoCompleteConfig?.DisplayProperties"
                          AutoCompleteValueProperties="@autoCompleteConfig?.ValueProperties"
                          DataLoader="@LoadProductionScheduleData"
                          UseGenericSave="true"
                          CustomValidator="@ValidateScheduleItemsAsync"
                          AfterSave="@SaveScheduleItemsAsync"
                          CustomDeleteHandler="@DeleteProductionScheduleAsync"
                          SaveSuccessMessage="@(ProductionScheduleId.HasValue ? "生產排程更新成功" : "生產排程新增成功")"
                          SaveFailureMessage="生產排程儲存失敗"
                          RequiredPermission="ProductionSchedule.Read"
                          OnSaveSuccess="@HandleSaveSuccess"
                          OnCancel="@HandleCancel"
                          OnEntityLoaded="@HandleEntityLoaded"
                          CustomModules="@GetCustomModules()" />

@* 排程項目編輯 Modal *@
<ProductionScheduleItemEditModal IsVisible="@showScheduleItemModal"
                                 IsVisibleChanged="@((bool visible) => showScheduleItemModal = visible)"
                                 ProductionScheduleItemId="@selectedScheduleItemId"
                                 IsReadOnly="@IsReadOnly"
                                 OnSaved="@HandleScheduleItemSaved"
                                 OnCancel="@(() => showScheduleItemModal = false)" />

@code {
    // ===== 參數 =====
    [Parameter] public bool IsVisible { get; set; } = false;
    [Parameter] public EventCallback<bool> IsVisibleChanged { get; set; }
    [Parameter] public int? ProductionScheduleId { get; set; }
    [Parameter] public EventCallback<ProductionSchedule> OnProductionScheduleSaved { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public Dictionary<string, object?>? PrefilledValues { get; set; }
    [Parameter] public bool IsReadOnly { get; set; } = false;

    // ===== 內部狀態 =====
    private GenericEditModalComponent<ProductionSchedule, IProductionScheduleService>? editModalComponent;
    private List<FormFieldDefinition> formFields = new();
    private Dictionary<string, string> formSections = new();
    private List<Customer> availableCustomers = new();
    private List<Employee> availableEmployees = new();
    private List<Product> availableProducts = new();
    private List<SalesOrder> availableSalesOrders = new();
    
    // AutoComplete 配置
    private AutoCompleteConfig? autoCompleteConfig;
    
    // ===== 排程項目相關 =====
    private List<ProductionScheduleItem> scheduleItems = new();
    private bool showScheduleItemModal = false;
    private int? selectedScheduleItemId = null;
    
    // ===== 雙表格設計相關 =====
    private List<PendingScheduleDetailDto> pendingDetails = new();
    private List<ScheduleItemDto> currentScheduleItems = new();
    
    // ===== 待刪除項目列表（等待主檔儲存時才真正刪除） =====
    private List<ScheduleItemDto> itemsToDelete = new();
    
    // 資料載入狀態標記
    private bool isDataLoaded = false;
    
    // 防止重複載入的標記
    private bool _isLoadingScheduleItems = false;
    private bool _isLoadingPendingDetails = false;
    private int? _lastLoadedScheduleId = null;

    // ===== 生命週期 =====
    
    /// <summary>
    /// 處理實體載入完成事件（由 GenericEditModalComponent 的導航觸發）
    /// 當上下筆切換時觸發 UI 更新，確保表單欄位正確渲染
    /// </summary>
    private async Task HandleEntityLoaded(int loadedEntityId)
    {
        try
        {
            // 載入排程項目
            await LoadScheduleItemsAsync(loadedEntityId);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"載入資料時發生錯誤：{ex.Message}");
        }
    }
    
    private async Task LoadScheduleItemsAsync(int scheduleId, bool forceReload = false)
    {
        // 防止重複載入：如果正在載入，跳過
        if (_isLoadingScheduleItems)
        {
            return;
        }
        
        // 防止重複載入：如果已載入相同 ID 且資料存在且非強制重載，跳過
        if (!forceReload && _lastLoadedScheduleId == scheduleId && currentScheduleItems.Any())
        {
            return;
        }
        
        // 設定載入中標記
        _isLoadingScheduleItems = true;
        _lastLoadedScheduleId = scheduleId;
        
        try
        {
            // 清空待刪除列表（載入新資料時重置）
            itemsToDelete.Clear();
            
            scheduleItems = await ProductionScheduleItemService.GetByScheduleIdAsync(scheduleId);
            
            // 將已儲存的排程項目轉換為 DTO 並載入到 currentScheduleItems
            currentScheduleItems = scheduleItems.Select(item => new ScheduleItemDto
            {
                Id = item.Id,
                SalesOrderDetailId = item.SalesOrderDetailId ?? 0,
                SalesOrderId = item.SalesOrderDetail?.SalesOrderId ?? 0,
                SalesOrderCode = item.SalesOrderDetail?.SalesOrder?.Code ?? "",
                ProductId = item.ProductId,
                ProductCode = item.Product?.Code ?? "",
                ProductName = item.Product?.Name ?? "未知商品",
                OrderQuantity = item.SalesOrderDetail?.OrderQuantity ?? 0,
                ScheduleQuantity = item.ScheduledQuantity,
                CompletedQuantity = item.CompletedQuantity,
                Status = item.ProductionItemStatus,
                CustomerName = item.SalesOrderDetail?.SalesOrder?.Customer?.CompanyName,
                IsNew = false, // 已儲存的項目
                SortOrder = item.Priority, // 讀取排序順序
                CanDelete = item.CompletedQuantity == 0, // 只有尚未開始生產的才可刪除
                IsClosed = item.IsClosed // 載入結案狀態
            }).ToList();
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"載入排程項目失敗: {ex.Message}");
            scheduleItems = new();
            currentScheduleItems = new();
        }
        finally
        {
            // 重設載入中標記
            _isLoadingScheduleItems = false;
        }
    }

    // ===== 事件處理 =====
    
    /// <summary>
    /// 儲存排程項目（AfterSave 回調）
    /// 將 currentScheduleItems 轉換為 ProductionScheduleItem 並儲存到資料庫
    /// 同時更新 SalesOrderDetail.ScheduledQuantity
    /// </summary>
    private async Task SaveScheduleItemsAsync(ProductionSchedule savedSchedule)
    {
        try
        {
            var successCount = 0;
            var failedItems = new List<string>();
            
            // ===== 1. 處理待刪除的項目 =====
            foreach (var item in itemsToDelete)
            {
                try
                {
                    if (item.Id.HasValue)
                    {
                        // 回寫 SalesOrderDetail.ScheduledQuantity
                        if (item.SalesOrderDetailId > 0)
                        {
                            var salesOrderDetail = await SalesOrderDetailService.GetByIdAsync(item.SalesOrderDetailId);
                            if (salesOrderDetail != null)
                            {
                                salesOrderDetail.ScheduledQuantity = Math.Max(0, salesOrderDetail.ScheduledQuantity - item.ScheduleQuantity);
                                await SalesOrderDetailService.UpdateAsync(salesOrderDetail);
                            }
                        }
                        
                        // 從資料庫刪除 ProductionScheduleItem
                        await ProductionScheduleItemService.PermanentDeleteAsync(item.Id.Value);
                    }
                }
                catch (Exception ex)
                {
                    failedItems.Add($"刪除 {item.ProductName}: {ex.Message}");
                }
            }
            
            // 清空待刪除列表
            itemsToDelete.Clear();
            
            // ===== 2. 更新所有項目的排序順序（根據目前列表順序）=====
            for (var i = 0; i < currentScheduleItems.Count; i++)
            {
                currentScheduleItems[i].SortOrder = i;
            }
            
            // ===== 3. 更新已存在項目的 Priority（排序順序）與 IsClosed（結案狀態）=====
            var existingItems = currentScheduleItems.Where(x => !x.IsNew && x.Id.HasValue).ToList();
            
            foreach (var dto in existingItems)
            {
                try
                {
                    var existingItem = await ProductionScheduleItemService.GetByIdAsync(dto.Id!.Value);
                    if (existingItem != null)
                    {
                        var needUpdate = false;
                        
                        // 檢查是否需要更新排序順序
                        if (existingItem.Priority != dto.SortOrder)
                        {
                            existingItem.Priority = dto.SortOrder;
                            needUpdate = true;
                        }
                        
                        // 檢查是否需要更新結案狀態
                        if (existingItem.IsClosed != dto.IsClosed)
                        {
                            existingItem.IsClosed = dto.IsClosed;
                            needUpdate = true;
                        }
                        
                        if (needUpdate)
                        {
                            await ProductionScheduleItemService.UpdateAsync(existingItem);
                        }
                    }
                }
                catch
                {
                    // 排序/結案更新失敗不中斷流程
                }
            }
            
            // ===== 4. 處理新增的項目 =====
            var newItems = currentScheduleItems.Where(x => x.IsNew).ToList();
            
            // 如果沒有新增的排程項目，完成儲存
            if (!newItems.Any())
            {
                // 如果有刪除失敗的項目，顯示警告
                if (failedItems.Any())
                {
                    await NotificationService.ShowWarningAsync($"部分項目處理失敗：\n{string.Join("\n", failedItems)}");
                }
                return;
            }
            
            foreach (var dto in newItems)
            {
                try
                {
                    // 1. 建立 ProductionScheduleItem 實體
                    var scheduleItem = new ProductionScheduleItem
                    {
                        ProductionScheduleId = savedSchedule.Id,
                        ProductId = dto.ProductId,
                        SalesOrderDetailId = dto.SalesOrderDetailId,
                        ScheduledQuantity = dto.ScheduleQuantity,
                        CompletedQuantity = 0,
                        ProductionItemStatus = ProductionItemStatus.Pending,
                        Priority = dto.SortOrder, // 儲存排序順序
                        Status = EntityStatus.Active,
                        CreatedAt = DateTime.Now
                    };
                    
                    // 2. 儲存 ProductionScheduleItem
                    var itemResult = await ProductionScheduleItemService.CreateAsync(scheduleItem);
                    
                    if (!itemResult.IsSuccess)
                    {
                        failedItems.Add($"{dto.ProductName}: {itemResult.ErrorMessage}");
                        continue;
                    }
                    
                    // 3. 更新 SalesOrderDetail.ScheduledQuantity（回寫）
                    if (dto.SalesOrderDetailId > 0)
                    {
                        var salesOrderDetail = await SalesOrderDetailService.GetByIdAsync(dto.SalesOrderDetailId);
                        if (salesOrderDetail != null)
                        {
                            salesOrderDetail.ScheduledQuantity += dto.ScheduleQuantity;
                            await SalesOrderDetailService.UpdateAsync(salesOrderDetail);
                        }
                    }
                    
                    // 標記為已儲存
                    dto.IsNew = false;
                    dto.Id = scheduleItem.Id;
                    successCount++;
                }
                catch (Exception ex)
                {
                    failedItems.Add($"{dto.ProductName}: {ex.Message}");
                }
            }
            
            // 如果有失敗的項目，顯示警告
            if (failedItems.Any())
            {
                await NotificationService.ShowWarningAsync($"部分項目儲存失敗：\n{string.Join("\n", failedItems)}");
            }
            
            // 重新載入已儲存的排程項目（強制重載，因為資料已變更）
            await LoadScheduleItemsAsync(savedSchedule.Id, forceReload: true);
            
            // 重新載入待排程明細（強制重載）
            await LoadPendingDetailsAsync(forceReload: true);
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"儲存排程項目失敗: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 驗證排程項目 - 確保至少有一筆排程項目
    /// </summary>
    private async Task<bool> ValidateScheduleItemsAsync(ProductionSchedule schedule)
    {
        // 檢查是否有排程項目（包含新增和已儲存的）
        if (!currentScheduleItems.Any())
        {
            await NotificationService.ShowWarningAsync("請至少加入一筆排程項目");
            return false;
        }
        
        // 檢查所有項目的排程數量是否大於 0
        var invalidItems = currentScheduleItems.Where(x => x.ScheduleQuantity <= 0).ToList();
        if (invalidItems.Any())
        {
            var productNames = string.Join("、", invalidItems.Select(x => x.ProductName).Take(3));
            await NotificationService.ShowWarningAsync($"以下商品的排程數量必須大於 0：{productNames}");
            return false;
        }
        
        return true;
    }
    
    /// <summary>
    /// 自訂刪除處理器 - 刪除排程時回寫 SalesOrderDetail.ScheduledQuantity
    /// </summary>
    private async Task<bool> DeleteProductionScheduleAsync(ProductionSchedule schedule)
    {
        try
        {
            // 1. 取得所有排程項目
            var itemsToDelete = await ProductionScheduleItemService.GetByScheduleIdAsync(schedule.Id);
            
            // 2. 回寫每個 SalesOrderDetail 的 ScheduledQuantity
            foreach (var item in itemsToDelete)
            {
                if (item.SalesOrderDetailId.HasValue && item.SalesOrderDetailId.Value > 0)
                {
                    var salesOrderDetail = await SalesOrderDetailService.GetByIdAsync(item.SalesOrderDetailId.Value);
                    if (salesOrderDetail != null)
                    {
                        // 減少已排程數量
                        salesOrderDetail.ScheduledQuantity = Math.Max(0, salesOrderDetail.ScheduledQuantity - item.ScheduledQuantity);
                        await SalesOrderDetailService.UpdateAsync(salesOrderDetail);
                    }
                }
                
                // 3. 刪除排程項目
                await ProductionScheduleItemService.PermanentDeleteAsync(item.Id);
            }
            
            // 4. 刪除主檔
            var result = await ProductionScheduleService.PermanentDeleteAsync(schedule.Id);
            
            if (result.IsSuccess)
            {
                await NotificationService.ShowSuccessAsync("生產排程已刪除");
                return true;
            }
            else
            {
                await NotificationService.ShowErrorAsync($"刪除失敗：{result.ErrorMessage}");
                return false;
            }
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"刪除排程時發生錯誤：{ex.Message}");
            return false;
        }
    }
    
    private async Task HandleSaveSuccess()
    {
        try
        {
            // 如果父組件需要知道排程已儲存
            if (OnProductionScheduleSaved.HasDelegate && editModalComponent?.Entity != null)
            {
                await OnProductionScheduleSaved.InvokeAsync(editModalComponent.Entity);
            }
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"處理儲存成功事件時發生錯誤：{ex.Message}");
        }
    }

    private async Task HandleCancel()
    {
        try
        {
            // 清空待刪除列表（取消時不執行刪除）
            itemsToDelete.Clear();
            
            if (OnCancel.HasDelegate)
            {
                await OnCancel.InvokeAsync();
            }

            await CloseModal();
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"處理取消事件時發生錯誤：{ex.Message}");
        }
    }

    private async Task CloseModal()
    {
        if (IsVisibleChanged.HasDelegate)
        {
            await IsVisibleChanged.InvokeAsync(false);
        }
    }

    // ===== 資料載入 =====
    private async Task LoadAdditionalDataAsync()
    {
        try
        {
            // 載入客戶列表
            availableCustomers = await CustomerService.GetAllAsync();
            
            // 載入員工列表（排除超級管理員）
            var allEmployees = await EmployeeService.GetAllAsync();
            availableEmployees = allEmployees.Where(e => !e.IsSuperAdmin).ToList();
            
            // 載入商品列表（用於顯示排程項目）
            availableProducts = await ProductService.GetAllAsync();
            
            // 載入銷貨訂單列表
            availableSalesOrders = await SalesOrderService.GetAllAsync();
            
            // 建立 AutoComplete 配置
            autoCompleteConfig = new AutoCompleteConfigBuilder<ProductionSchedule>()
                .AddField(nameof(ProductionSchedule.CreatedByEmployeeId), "Name", availableEmployees)
                .Build();
            
            // 載入待排程明細列表（雙表格設計 - 改為以明細為主）
            await LoadPendingDetailsAsync();
            
            // 初始化當前排程項目列表
            currentScheduleItems = new List<ScheduleItemDto>();
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"載入相關資料時發生錯誤：{ex.Message}");
            availableCustomers = new List<Customer>();
            availableEmployees = new List<Employee>();
            availableProducts = new List<Product>();
            availableSalesOrders = new List<SalesOrder>();
            pendingDetails = new List<PendingScheduleDetailDto>();
            currentScheduleItems = new List<ScheduleItemDto>();
        }
    }

    private async Task<ProductionSchedule?> LoadProductionScheduleData()
    {
        try
        {
            if (!ProductionScheduleId.HasValue) 
            {
                // 新增模式：建立新的排程實體並生成編號
                var newSchedule = new ProductionSchedule
                {
                    Code = await EntityCodeGenerationHelper.GenerateForEntity<ProductionSchedule, IProductionScheduleService>(ProductionScheduleService, "PS"),
                    ScheduleDate = DateTime.Today,
                    Status = EntityStatus.Active
                };
                
                // 應用預填值
                PrefilledValueHelper.ApplyPrefilledValues(newSchedule, PrefilledValues);
                
                return newSchedule;
            }

            var schedule = await ProductionScheduleService.GetByIdAsync(ProductionScheduleId.Value);            
            
            if (schedule == null)
            {
                // 如果找不到排程，建立新的預設排程
                return new ProductionSchedule
                {
                    ScheduleDate = DateTime.Today,
                    Status = EntityStatus.Active
                };
            }
            return schedule;
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"載入生產排程資料時發生錯誤：{ex.Message}");
            
            // 設定安全的預設值，確保程式不會崩潰
            return new ProductionSchedule
            {
                Code = "ERROR",
                ScheduleDate = DateTime.Today,
                Status = EntityStatus.Active
            };
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (IsVisible && !isDataLoaded)
        {
            // 先載入資料（包含 AutoComplete 配置）
            await LoadAdditionalDataAsync();
            // 再初始化表單欄位
            InitializeFormFields();
            isDataLoaded = true;
            
            // 如果是編輯模式且有 ProductionScheduleId，載入排程項目
            if (ProductionScheduleId.HasValue)
            {
                await LoadScheduleItemsAsync(ProductionScheduleId.Value);
            }
            else
            {
                // 新增模式時清空列表
                scheduleItems = new();
                currentScheduleItems = new();
                itemsToDelete.Clear();
            }
        }
        else if (!IsVisible)
        {
            isDataLoaded = false;
            // 重設所有載入狀態標記，確保下次開啟時乾淨狀態
            _isLoadingScheduleItems = false;
            _isLoadingPendingDetails = false;
            _lastLoadedScheduleId = null;
        }
    }

    // ===== 表單初始化 =====
    private void InitializeFormFields()
    {
        try
        {
            formFields = new List<FormFieldDefinition>
            {
                // 基本資訊區段
                new()
                {
                    PropertyName = nameof(ProductionSchedule.Code),
                    Label = "排程編號",
                    FieldType = FormFieldType.Text,
                    Placeholder = "請輸入排程編號",
                    IsRequired = true,
                    HelpText = "排程的唯一識別編號，新增時系統會自動產生，也可手動修改"
                },
                new()
                {
                    PropertyName = nameof(ProductionSchedule.ScheduleDate),
                    Label = "排程日期",
                    FieldType = FormFieldType.Date,
                    IsRequired = true,
                    HelpText = "排程建立日期"
                },
                new()
                {
                    PropertyName = nameof(ProductionSchedule.CreatedByEmployeeId),
                    Label = "製單人員",
                    FieldType = FormFieldType.AutoComplete,
                    Placeholder = "請輸入或選擇製單人員",
                    MinSearchLength = 0,
                    IsRequired = true,
                    HelpText = "輸入員工名稱進行搜尋，或直接選擇"
                },

                FormFieldConfigurationHelper.CreateRemarksField<ProductionSchedule>()
            };

            formSections = FormSectionHelper<ProductionSchedule>.Create()
                .AddToSection(FormSectionNames.BasicInfo,
                    ps => ps.Code,
                    ps => ps.ScheduleDate,
                    ps => ps.CreatedByEmployeeId)
                .AddToSection(FormSectionNames.AdditionalData,
                    ps => ps.Remarks)
                .Build();
        }
        catch (Exception)
        {
            _ = NotificationService.ShowErrorAsync("初始化表單欄位時發生錯誤");
        }
    }

    // ===== 自訂模組 =====
    private List<GenericEditModalComponent<ProductionSchedule, IProductionScheduleService>.CustomModule> GetCustomModules()
    {
        try
        {
            return new List<GenericEditModalComponent<ProductionSchedule, IProductionScheduleService>.CustomModule>
            {
                new GenericEditModalComponent<ProductionSchedule, IProductionScheduleService>.CustomModule
                {
                    Title = "",
                    Content = CreateScheduleItemsContent(),
                    Order = 1
                }
            };
        }
        catch
        {
            return new List<GenericEditModalComponent<ProductionSchedule, IProductionScheduleService>.CustomModule>();
        }
    }

    /// <summary>
    /// 創建排程項目列表內容 - 雙表格設計（左側明細、右側排程項目）
    /// </summary>
    private RenderFragment CreateScheduleItemsContent() => __builder =>
    {
        <div class="row mt-3">
            @* 左側：待排程明細表格（以商品為核心） *@
            <div class="col-md-6">
                <ProductionScheduleOrderTable Details="@pendingDetails"
                                              OnDetailSelected="@HandleDetailSelected"
                                              OnRefreshRequested="@HandleRefreshPendingDetails" />
            </div>
            
            @* 右側：排程項目表格（已儲存+新增的項目都在這裡顯示） *@
            <div class="col-md-6">
                <ProductionScheduleItemTable Items="@currentScheduleItems"
                                             IsReadOnly="@IsReadOnly"
                                             OnItemRemoved="@HandleScheduleItemRemoved"
                                             OnQuantityChanged="@HandleScheduleItemQuantityChanged"
                                             OnDetailDropped="@HandleDetailDropped"
                                             OnOrderChanged="@HandleScheduleItemOrderChanged"
                                             OnIsClosedChanged="@HandleScheduleItemIsClosedChanged" />
            </div>
        </div>
    };

    /// <summary>
    /// <summary>
    /// 取得狀態標籤
    /// </summary>
    private RenderFragment GetStatusBadge(ProductionItemStatus status) => __builder =>
    {
        var (badgeClass, icon, text) = status switch
        {
            ProductionItemStatus.Pending => ("bg-secondary", "bi-clock", "待處理"),
            ProductionItemStatus.InProgress => ("bg-warning text-dark", "bi-play-circle", "生產中"),
            ProductionItemStatus.Completed => ("bg-success", "bi-check-circle", "已完成"),
            _ => ("bg-secondary", "bi-question-circle", "未知")
        };
        
        <span class="badge @badgeClass">
            <i class="@icon me-1"></i>@text
        </span>
    };

    /// <summary>
    /// 開啟排程項目詳情（用於點擊已儲存的項目時開啟編輯 Modal）
    /// </summary>
    private void HandleOpenScheduleItem(int itemId)
    {
        selectedScheduleItemId = itemId;
        showScheduleItemModal = true;
        StateHasChanged();
    }

    /// <summary>
    /// 處理排程項目儲存後的事件
    /// </summary>
    private async Task HandleScheduleItemSaved(ProductionScheduleItem savedItem)
    {
        // 更新列表中的項目
        var index = scheduleItems.FindIndex(x => x.Id == savedItem.Id);
        if (index >= 0)
        {
            scheduleItems[index] = savedItem;
        }
        
        showScheduleItemModal = false;
        selectedScheduleItemId = null;
        StateHasChanged();
        
        await Task.CompletedTask;
    }

    // ===== 雙表格設計事件處理 =====

    /// <summary>
    /// 載入待排程明細列表（以明細為核心，直接顯示所有待排程商品）
    /// </summary>
    private async Task LoadPendingDetailsAsync(bool forceReload = false)
    {
        // 防止重複載入：如果正在載入，跳過
        if (_isLoadingPendingDetails)
        {
            return;
        }
        
        // 防止重複載入：如果資料已存在且非強制重載，跳過
        if (!forceReload && pendingDetails.Any())
        {
            return;
        }
        
        // 設定載入中標記
        _isLoadingPendingDetails = true;
        
        try
        {
            pendingDetails = new List<PendingScheduleDetailDto>();
            
            // 取得所有銷貨訂單
            var salesOrders = await SalesOrderService.GetAllAsync();
            
            foreach (var order in salesOrders)
            {
                // 取得訂單明細
                var details = await SalesOrderDetailService.GetBySalesOrderIdWithIncludesAsync(order.Id);
                
                foreach (var detail in details)
                {
                    // 從 ProductionScheduleItem 計算已排程數量
                    var scheduledQty = await GetScheduledQuantityForOrderDetailAsync(detail.Id);
                    
                    // 減去待刪除項目的數量（這些項目尚未從資料庫刪除，但使用者已在 UI 上移除）
                    var pendingDeleteQty = itemsToDelete
                        .Where(item => item.SalesOrderDetailId == detail.Id)
                        .Sum(item => item.ScheduleQuantity);
                    scheduledQty -= pendingDeleteQty;
                    
                    // 檢查是否已經在當前排程項目列表中（尚未儲存的）
                    var currentScheduleQty = currentScheduleItems
                        .Where(si => si.SalesOrderDetailId == detail.Id)
                        .Sum(si => si.ScheduleQuantity);
                    
                    var totalScheduled = scheduledQty + currentScheduleQty;
                    var remaining = detail.OrderQuantity - totalScheduled;
                    
                    if (remaining > 0)
                    {
                        pendingDetails.Add(new PendingScheduleDetailDto
                        {
                            SalesOrderDetailId = detail.Id,
                            SalesOrderId = order.Id,
                            SalesOrderCode = order.Code ?? "",
                            OrderDate = order.OrderDate,
                            ExpectedDeliveryDate = order.ExpectedDeliveryDate,
                            CustomerId = order.CustomerId,
                            CustomerName = order.Customer?.CompanyName ?? "未知客戶",
                            ProductId = detail.ProductId,
                            ProductCode = detail.Product?.Code ?? "",
                            ProductName = detail.Product?.Name ?? "未知商品",
                            OrderQuantity = detail.OrderQuantity,
                            ScheduledQuantity = totalScheduled,
                            PendingQuantity = remaining,
                            ScheduleQuantity = remaining // 預設排程全部待排數量
                        });
                    }
                }
            }
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"載入待排程明細失敗: {ex.Message}");
            pendingDetails = new();
        }
        finally
        {
            // 重設載入中標記
            _isLoadingPendingDetails = false;
        }
    }

    /// <summary>
    /// 取得訂單明細已排程數量
    /// </summary>
    private async Task<decimal> GetScheduledQuantityForOrderDetailAsync(int salesOrderDetailId)
    {
        try
        {
            // 查詢已排程數量（排除目前排程中尚未儲存的項目）
            var allItems = await ProductionScheduleItemService.GetAllAsync();
            return allItems
                .Where(item => item.SalesOrderDetailId == salesOrderDetailId)
                .Sum(item => item.ScheduledQuantity);
        }
        catch
        {
            return 0;
        }
    }

    /// <summary>
    /// 處理明細選擇事件（點擊行直接加入排程）
    /// </summary>
    private async Task HandleDetailSelected(PendingScheduleDetailDto detail)
    {
        await AddDetailToSchedule(detail);
    }

    /// <summary>
    /// 處理拖放明細事件（從左側表格拖放到右側）
    /// </summary>
    private async Task HandleDetailDropped(PendingScheduleDetailDto detail)
    {
        await AddDetailToSchedule(detail);
    }

    /// <summary>
    /// 將明細加入排程項目列表
    /// </summary>
    private async Task AddDetailToSchedule(PendingScheduleDetailDto detail)
    {
        try
        {
            // 檢查是否已存在
            var existingItem = currentScheduleItems.FirstOrDefault(
                si => si.SalesOrderDetailId == detail.SalesOrderDetailId);
            
            if (existingItem != null)
            {
                // 已存在，更新數量
                existingItem.ScheduleQuantity += detail.PendingQuantity;
                await NotificationService.ShowInfoAsync($"已更新 {detail.ProductName} 的排程數量");
            }
            else
            {
                // 新增項目
                currentScheduleItems.Add(new ScheduleItemDto
                {
                    SalesOrderId = detail.SalesOrderId,
                    SalesOrderCode = detail.SalesOrderCode,
                    SalesOrderDetailId = detail.SalesOrderDetailId,
                    ProductId = detail.ProductId,
                    ProductCode = detail.ProductCode,
                    ProductName = detail.ProductName,
                    OrderQuantity = detail.OrderQuantity, // 訂單量
                    ScheduleQuantity = detail.PendingQuantity,
                    PendingScheduleQuantity = 0, // 加入後待排為 0
                    CustomerName = detail.CustomerName,
                    Status = ProductionItemStatus.Pending,
                    IsNew = true,
                    CanDelete = true
                });
            }
            
            // 重新載入待排程明細列表（強制重載，因為已排程數量變更）
            await LoadPendingDetailsAsync(forceReload: true);
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"加入排程項目失敗: {ex.Message}");
        }
    }

    /// <summary>
    /// 處理排程項目移除 - 先記錄到待刪除列表，等主檔儲存時才真正刪除
    /// 參考 PurchaseOrderTable 的做法：移除時只從列表中移除，不立即刪除資料庫
    /// </summary>
    private async Task HandleScheduleItemRemoved(ScheduleItemDto item)
    {
        try
        {
            // 如果是已儲存的項目（非新增），記錄到待刪除列表
            if (!item.IsNew && item.Id.HasValue)
            {
                itemsToDelete.Add(item);
            }
            
            // 從顯示列表中移除
            currentScheduleItems.Remove(item);
            
            // 重新載入待排程明細列表（強制重載，因為已排程數量變更）
            await LoadPendingDetailsAsync(forceReload: true);
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await NotificationService.ShowErrorAsync($"移除排程項目失敗: {ex.Message}");
        }
    }

    /// <summary>
    /// 處理排程項目數量變更
    /// </summary>
    private void HandleScheduleItemQuantityChanged((ScheduleItemDto Item, decimal NewQuantity) args)
    {
        args.Item.ScheduleQuantity = args.NewQuantity;
        StateHasChanged();
    }

    /// <summary>
    /// 處理排程項目順序變更（拖曳排序）
    /// 子組件已處理列表重排，這裡只需更新 SortOrder 並觸發重新渲染
    /// </summary>
    private void HandleScheduleItemOrderChanged((int OldIndex, int NewIndex) args)
    {
        // 更新所有項目的 SortOrder 以反映新順序
        for (var i = 0; i < currentScheduleItems.Count; i++)
        {
            currentScheduleItems[i].SortOrder = i;
        }
        StateHasChanged();
    }
    
    /// <summary>
    /// 處理排程項目結案狀態變更
    /// </summary>
    private void HandleScheduleItemIsClosedChanged((ScheduleItemDto Item, bool IsClosed) args)
    {
        // DTO 中的 IsClosed 已經在 Table 元件中更新，這裡只需要刷新 UI
        StateHasChanged();
    }

    /// <summary>
    /// 處理刷新待排程明細請求
    /// </summary>
    private async Task HandleRefreshPendingDetails()
    {
        // 強制重載，因為使用者明確要求刷新
        await LoadPendingDetailsAsync(forceReload: true);
        StateHasChanged();
    }

    // ===== 公開方法 (供父組件調用) =====

    /// <summary>
    /// 開啟新增生產排程 Modal
    /// </summary>
    public async Task ShowAddModal()
    {
        ProductionScheduleId = null;
        scheduleItems = new();
        if (IsVisibleChanged.HasDelegate)
        {
            await IsVisibleChanged.InvokeAsync(true);
        }
    }

    /// <summary>
    /// 開啟編輯生產排程 Modal
    /// </summary>
    public async Task ShowEditModal(int scheduleId)
    {
        ProductionScheduleId = scheduleId;
        if (IsVisibleChanged.HasDelegate)
        {
            await IsVisibleChanged.InvokeAsync(true);
        }
    }
}
